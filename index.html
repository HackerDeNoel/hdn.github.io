<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HDN Christmas Project 2025</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">

    <!-- Supabase JS Client -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <!-- QR Code Scanner -->
    <script src="https://unpkg.com/html5-qrcode@2.3.8/html5-qrcode.min.js"></script>
    <!-- QRCode.js for generation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Orbitron', sans-serif;
            background-color: #000000;
            color: #ffffff;
            min-height: 100vh;
            width: 100%;
            display: block;
        }

        p {
            font-size: clamp(0.875rem, 0.125vw + 0.85rem, 1rem);
        }

        .container {
            max-width: 1281px;
  margin: 0 auto;
  padding: 10px;
  display: flex;
  flex-flow: column nowrap;
  justify-content: center;
  align-items: center;
        }

        /* Header */
        header {
            background: linear-gradient(135deg, #343973, #4a5193);
            padding: 30px 20px;
            margin-bottom: 30px;
        }

        header h1 {
            text-align: center;
            font-size: clamp(1.125rem, 0.75vw + 0.975rem, 1.875rem);
            color: #81FE0E;
            text-transform: uppercase;
            letter-spacing: 5px;
            margin-bottom: 10px;
        }

        header p {
            text-align: center;
            color: #ffffff;
            font-size: 16px;
            opacity: 0.9;
        }

        /* Cards */
        .card {
            background: white;
            color: #000000;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            max-width: 1000px;
            margin-left: auto;
            margin-right: auto;
            width: 100%;
        }

        .card h2 {
            color: #343973;
            margin-bottom: 20px;
            font-size: 1.8em;
            border-bottom: 3px solid #81FE0E;
            padding-bottom: 10px;
        }

        .card h3 {
            color: #343973;
            margin: 20px 0 15px 0;
            font-size: 1.3em;
        }

        /* Navigation */
        nav {
            background: white;
  border-radius: 15px;
  padding: 20px;
  margin-bottom: 30px;
  box-shadow: 0 0 30px rgba(129, 254, 14, 0.2);
  display: flex;
  gap: 10px;
  flex-wrap: wrap;
  justify-content: center;
  width: 100%;
  max-width: 1000px;
        }

        nav button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.9em;
            background: #343973;
            color: white;
        }

        nav button:hover {
            background: #4a5193;
            transform: translateY(-2px);
        }

        nav button.active {
            background: #81FE0E;
            color: #000000;
        }

        /* Buttons */
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s;
            margin: 5px;
            font-size: 0.9em;
        }

        .btn-primary {
            background: #343973;
            color: white;
        }

        .btn-primary:hover {
            background: #4a5193;
            transform: translateY(-2px);
        }

        .btn-success {
            background: #81FE0E;
            color: #000000;
        }

        .btn-success:hover {
            background: #6dd90c;
            transform: translateY(-2px);
        }

        .btn-danger {
            background: #ff4444;
            color: white;
        }

        .btn-danger:hover {
            background: #cc0000;
            transform: translateY(-2px);
        }

        .btn-warning {
            background: #ffaa00;
            color: #000000;
        }

        .btn-warning:hover {
            background: #ff8800;
            transform: translateY(-2px);
        }

        /* Forms */
        input, select, textarea {
            width: 100%;
            padding: 12px;
            margin: 10px 0;
            border: 2px solid #343973;
            border-radius: 8px;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.9em;
        }

        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: #81FE0E;
            box-shadow: 0 0 10px rgba(129, 254, 14, 0.3);
        }

        label {
            display: block;
            margin-top: 15px;
            margin-bottom: 5px;
            color: #343973;
            font-weight: 700;
        }

        /* Password input with eye toggle */
        .password-container {
            position: relative;
            width: 100%;
        }

        .password-container input {
            width: 100%;
            padding-right: 50px;
        }

        .password-toggle {
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1.2em;
            color: #343973;
            padding: 5px;
            opacity: 0.7;
            transition: opacity 0.2s;
        }

        .password-toggle:hover {
            opacity: 1;
        }

        /* Radio buttons */
        .radio-group {
            display: flex;
            gap: 20px;
            margin: 15px 0;
        }

        .radio-option {
            flex: 1;
            padding: 15px;
            border: 2px solid #343973;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
            background: white;
        }

        .radio-option:hover {
            border-color: #81FE0E;
            box-shadow: 0 0 15px rgba(129, 254, 14, 0.2);
        }

        .radio-option.active {
            border-color: #81FE0E;
            background: rgba(129, 254, 14, 0.1);
        }

        .radio-option input[type="radio"] {
            display: none;
        }

        /* Sections */
        .section {
            display: none;
        }

        .section.active {
            display: block;
            width: 100%;
        }

        /* Stats Grid */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-box {
            background: linear-gradient(135deg, #343973, #4a5193);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 0 20px rgba(129, 254, 14, 0.2);
        }

        .stat-box h3 {
            font-size: 2em;
            color: #81FE0E;
            margin-bottom: 5px;
        }

        .stat-box p {
            font-size: 0.9em;
            opacity: 0.9;
        }

        /* Enigmes List */
        .enigme-item {
            background: #f9f9f9;
            padding: 20px;
            margin: 15px 0;
            border-radius: 10px;
        }

        .enigme-item.solved {
            background: rgba(129, 254, 14, .12);
        }

        .enigme-item.locked {
            border-left-color: #ff4444;
            background: rgba(255, 68, 68, .12);
            opacity: 0.7;
        }

        .enigme-item h3 {
            color: #343973;
            margin-bottom: 10px;
        }

        /* Enigme Image */
        .enigme-image {
            width: 100%;
            max-width: 400px;
            height: auto;
            border-radius: 10px;
            margin: 15px auto;
            display: block;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        /* Badge */
        .badge {
            display: inline-block;
            padding: 5px 12px;
            border-radius: 5px;
            font-size: 0.8em;
            font-weight: 700;
            margin: 2px;
        }

        .badge-success {
            background: #81FE0E;
            color: #000000;
        }

        .badge-primary {
            background: #343973;
            color: white;
        }

        .badge-danger {
            background: #ff4444;
            color: white;
        }

        .badge-warning {
            background: #ffaa00;
            color: #000000;
        }

        /* Classement */
        .ranking-item {
            background: white;
            padding: 15px 20px;
            margin: 10px 0;
            border-radius: 10px;
            display: flex;
            align-items: center;
            gap: 15px;
            box-shadow: 0 0 15px rgba(129, 254, 14, 0.1);
        }

        .ranking-position {
            font-size: 2em;
            font-weight: 900;
            color: #343973;
            min-width: 50px;
            text-align: center;
        }

        .ranking-position.first { color: #FFD700; }
        .ranking-position.second { color: #C0C0C0; }
        .ranking-position.third { color: #CD7F32; }

        .ranking-info {
            flex: 1;
        }

        .ranking-points {
            font-size: 1.5em;
            font-weight: 700;
            color: #000;
        }

        /* Alert */
        .alert {
            padding: 15px 20px;
            border-radius: 8px;
            margin: 15px 0;
            font-weight: 700;
        }

        .alert-success {
            background: #81FE0E;
            color: #000000;
        }

        .alert-danger {
            background: #ff4444;
            color: white;
        }

        .alert-warning {
            background: #ffaa00;
            color: #000000;
        }

        .alert-info {
            background: #343973;
            color: white;
        }

        /* Timer */
        .timer {
            background: linear-gradient(135deg, #343973, #4a5193);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            margin: 20px 0;
            box-shadow: 0 0 20px rgba(129, 254, 14, 0.2);
        }

        .timer h2 {
            color: #81FE0E !important;
            font-size: 2.5em;
            margin: 0;
            border: none;
        }

        .timer p {
            font-size: 1.1em;
            margin-top: 10px;
            opacity: 0.9;
        }

        /* Loading */
        .loading {
            text-align: center;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Responsive */
        @media (max-width: 768px) {
            header h1 {
                font-size: 1.8em;
                letter-spacing: 2px;
            }

            .card {
                padding: 20px;
            }

            .stats-grid {
                grid-template-columns: 1fr;
            }

            .radio-group {
                flex-direction: column;
            }

            nav {
                flex-direction: column;
            }

            nav button {
                width: 100%;
            }
        }

        /* Hide/Show utilities */
        .hidden {
            display: none !important;
        }

        /* User info header */
        .user-info {
            background: white;
  padding: 15px 20px;
  border-radius: 10px;
  margin-bottom: 20px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  box-shadow: 0 0 20px rgba(129, 254, 14, 0.2);
  gap: 15px;
  width: 100%;
        }

        .user-info-left {
            color: #666;
            flex: 1;
        }

        .user-info-left strong {
            color: #000000;
            font-size: 1.3em;
            font-weight: 900;
        }
        
        .user-info-left span {
            color: #343973;
            font-size: 0.9em;
            margin-left: 10px;
        }

        /* Hints section */
        .hints-section {
            display: flex;
            flex-flow: column nowrap;
            justify-content: center;
            align-items: center;
            gap: 10px;
            background: #f0f0f0;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            border-left: 4px solid #343973;
        }

.hints-section div {
    display: flex;
    flex: column nowrap;
    gap: 10px;
}

@media screen and (min-width: 961px) {
    .hints-section div {
    flex: row nowrap;;
}
}

        .hint-item {
            padding: 10px;
            margin: 10px 0;
            background: white;
            border-radius: 8px;
        }

         .hint-item.locked {
            cursor: none;
            opacity: 0.5;
         }


        /* Lockout timer */
        .lockout-timer {
            background: linear-gradient(135deg, #ff4444, #cc0000);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            margin: 15px 0;
            font-weight: 700;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }

        .lockout-timer h3 {
            color: white !important;
            margin: 10px 0 !important;
            font-size: 2em;
        }

        /* QR Scanner */
        #qrScanner {
            margin: 20px auto;
            border: 3px solid #81FE0E;
            border-radius: 10px;
            overflow: hidden;
        }

        /* Toast Notification */
        .toast {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            color: #000;
            padding: 15px 25px;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(129, 254, 14, 0.5);
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            z-index: 9999;
            animation: slideUp 0.3s ease-out;
            max-width: 90%;
            word-wrap: break-word;
            white-space: pre-line;
        }

        .toast.success {
            background: #81FE0E;
            color: #000;
        }

        .toast.error {
            background: #ff4444;
            color: white;
        }

        .toast.warning {
            background: #ffaa00;
            color: #000;
        }

        .toast.info {
            background: #343973;
            color: white;
        }

        @keyframes slideUp {
            from {
                bottom: -100px;
                opacity: 0;
            }
            to {
                bottom: 30px;
                opacity: 1;
            }
        }

        /* Auth choice buttons */
        .auth-choice-container {
            display: flex;
            flex-flow: column nowrap;
            gap: 20px;
            margin: 30px 0;
        }

        @media screen and (min-width: 961px) {
            .auth-choice-container {
                flex-flow: row nowrap;
            }
        }

        .auth-choice-btn {
            flex: 1;
            padding: 30px 20px;
            border: 3px solid #343973;
            border-radius: 15px;
            background: white;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }

        .auth-choice-btn:hover {
            border-color: #81FE0E;
            transform: translateY(-5px);
            box-shadow: 0 5px 20px rgba(129, 254, 14, 0.3);
        }

        .auth-choice-btn h3 {
            color: #343973;
            margin: 10px 0;
            font-size: 1.5em;
        }

        .auth-choice-btn p {
            color: #666;
            margin: 10px 0 0 0;
        }

        /* QR Code Display */
        .qr-code-container {
            background: #f9f9f9;
            padding: 20px;
            border-radius: 10px;
            margin: 15px 0;
            text-align: center;
            border: 2px solid #343973;
        }

        .qr-code-container canvas,
        .qr-code-container img {
            margin: 15px auto;
            display: block;
            background: white;
            padding: 10px;
            border-radius: 8px;
        }

        /* Floating rules button */
.floating-rules-btn {
    position: fixed;
    bottom: 30px;
    right: 30px;
    background: #343973;
    color: white;
    padding: 15px 25px;
    border-radius: 50px;
    border: none;
    font-family: 'Orbitron', sans-serif;
    font-weight: 700;
    font-size: 1em;
    cursor: pointer;
    transition: all 0.3s;
    z-index: 1000;
}

.floating-rules-btn:hover {
    background: #81FE0E;
    color: #000;
    transform: translateY(-3px);
}

/* Rules modal */
.rules-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.9);
    z-index: 10000;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 20px;
}

.rules-modal-content {
    background: white;
    border-radius: 15px;
    padding: 10px;
    max-width: 800px;
    max-height: 80vh;
    overflow-y: auto;
    position: relative;
}

.rules-modal-close {
    position: absolute;
    top: 15px;
    right: 15px;
    background: #ff4444;
    color: white;
    border: none;
    border-radius: 50%;
    width: 40px;
    height: 40px;
    font-size: 1.5em;
    cursor: pointer;
    font-weight: bold;
}

.rules-modal-close:hover {
    background: #cc0000;
}
    </style>
</head>

<body>
    <!-- Header -->
    <header>
        <div class="container">
            <h1>üéÑ HDN Saison 3 üéÖ</h1>
            <p>Chasse au Tr√©sor 2025 | 25 Nov - 08 D√©c</p>
        </div>
    </header>

    <div class="container">
        <!-- User Info (hidden by default) -->
        <div class="user-info hidden" id="userInfo">
            <div class="user-info-left">
                <strong id="userPseudo"></strong>
                <span id="userTeamInfo"></span>
            </div>
            <button class="btn btn-danger" onclick="hdnApp.logout()">üö™ D√©connexion</button>
        </div>

        <!-- Navigation (hidden by default) -->
        <nav class="hidden" id="mainNav">
            <button onclick="hdnApp.showSection('home')">üè† Accueil</button>
            <button id="enigmaNavBtn" onclick="hdnApp.showSection('enigmes')">üí° √ânigmes</button>
            <button onclick="hdnApp.showSection('ranking')">üèÜ Classement</button>
            <button onclick="hdnApp.showSection('rules')">üìã R√®gles</button>
            <button class="hidden" id="adminNavBtn" onclick="hdnApp.showSection('admin')">‚öôÔ∏è Admin</button>
        </nav>

        <!-- AUTH SECTION -->
        <div class="section active" id="auth-section">
            <div class="card">
                <h2>üîê Bienvenue !</h2>

                <!-- Step 1: Already registered? -->
                <div id="authChoice">
                    <h3 style="text-align: center; margin-bottom: 20px;">√ätes-vous d√©j√† inscrit ?</h3>
                    <div class="auth-choice-container">
                        <div class="auth-choice-btn" onclick="hdnApp.showLogin()">
                            <h3>‚úÖ Oui</h3>
                            <p>Je me connecte</p>
                        </div>
                        <div class="auth-choice-btn" onclick="hdnApp.showRegister()">
                            <h3>‚ùå Non</h3>
                            <p>Je m'inscris</p>
                        </div>
                    </div>
                    <button class="floating-rules-btn" onclick="hdnApp.showRulesModal()">
                        üìã R√®gles du jeu
                    </button>
                </div>

                <!-- Step 2: Login Form (hidden) -->
                <div id="loginForm" class="hidden">
                    <h3>üîë Connexion</h3>
                    <label>Pseudo</label>
                    <input type="text" id="loginPseudo" placeholder="Ton pseudo" />

                    <label>Mot de passe (6 chiffres)</label>
                    <div class="password-container">
                        <input type="password" id="loginPassword" placeholder="123456" maxlength="6"
                               inputmode="numeric" pattern="[0-9]*"
                               oninput="this.value = this.value.replace(/[^0-9]/g, '')" />
                        <button type="button" class="password-toggle"
                                onclick="togglePassword('loginPassword', this)">üëÅÔ∏è</button>
                    </div>

                    <button class="btn btn-success" style="width: 100%; margin-top: 15px;" onclick="hdnApp.login()">
                        üöÄ Se connecter
                    </button>
                    <button class="btn btn-primary" style="width: 100%; margin-top: 10px;"
                            onclick="hdnApp.backToChoice()">
                        ‚Üê Retour
                    </button>
                </div>

                <!-- Step 3: Register Choice (hidden) -->
                <div id="registerChoice" class="hidden">
                    <h3 style="text-align: center; margin-bottom: 20px;">Comment voulez-vous jouer ?</h3>
                    <div class="radio-group">
                        <div class="radio-option" onclick="hdnApp.selectMode('solo')">
                            <input type="radio" name="mode" value="solo" id="modeSolo">
                            <label for="modeSolo" style="cursor: pointer; margin: 0;">
                                <h3 style="color: #343973; margin: 0;">üë§ Solo</h3>
                                <p style="margin-top: 5px; color: #666;">Jouer seul</p>
                            </label>
                        </div>
                        <div class="radio-option" onclick="hdnApp.selectMode('team')">
                            <input type="radio" name="mode" value="team" id="modeTeam">
                            <label for="modeTeam" style="cursor: pointer; margin: 0;">
                                <h3 style="color: #343973; margin: 0;">üë• √âquipe</h3>
                                <p style="margin-top: 5px; color: #666;">Jouer en √©quipe</p>
                            </label>
                        </div>
                    </div>
                    <button class="btn btn-primary" style="width: 100%; margin-top: 10px;"
                            onclick="hdnApp.backToChoice()">
                        ‚Üê Retour
                    </button>
                </div>

                <!-- Solo Registration Form (hidden) -->
                <div id="soloForm" class="hidden">
                    <h3>üìù Inscription Solo</h3>
                    <label>Pseudo *</label>
                    <input type="text" id="soloPseudo" placeholder="Ton pseudo" />

                    <label>Mot de passe (6 chiffres) *</label>
                    <div class="password-container">
                        <input type="password" id="soloPassword" placeholder="123456" maxlength="6"
                               inputmode="numeric" pattern="[0-9]*"
                               oninput="this.value = this.value.replace(/[^0-9]/g, '')" />
                        <button type="button" class="password-toggle"
                                onclick="togglePassword('soloPassword', this)">üëÅÔ∏è</button>
                    </div>

                    <button class="btn btn-success" style="width: 100%; margin-top: 15px;"
                            onclick="hdnApp.registerSolo()">
                        ‚úÖ S'inscrire Solo
                    </button>
                    <button class="btn btn-primary" style="width: 100%; margin-top: 10px;"
                            onclick="hdnApp.backToRegisterChoice()">
                        ‚Üê Retour
                    </button>
                </div>

                <!-- Team Action Selection (hidden) -->
                <div id="teamActionSelection" class="hidden">
                    <h3 style="text-align: center;">√âquipe</h3>
                    <div class="radio-group">
                        <div class="radio-option" onclick="hdnApp.selectTeamAction('create')">
                            <input type="radio" name="teamAction" value="create" id="actionCreate">
                            <label for="actionCreate" style="cursor: pointer; margin: 0;">
                                <h3 style="color: #343973; margin: 0;">‚ûï Cr√©er</h3>
                                <p style="margin-top: 5px; color: #666;">Nouvelle √©quipe</p>
                            </label>
                        </div>
                        <div class="radio-option" onclick="hdnApp.selectTeamAction('join')">
                            <input type="radio" name="teamAction" value="join" id="actionJoin">
                            <label for="actionJoin" style="cursor: pointer; margin: 0;">
                                <h3 style="color: #343973; margin: 0;">üîó Rejoindre</h3>
                                <p style="margin-top: 5px; color: #666;">√âquipe existante</p>
                            </label>
                        </div>
                    </div>
                    <button class="btn btn-primary" style="width: 100%; margin-top: 10px;"
                            onclick="hdnApp.backToRegisterChoice()">
                        ‚Üê Retour
                    </button>
                </div>

                <!-- Create Team Form (hidden) -->
                <div id="createTeamForm" class="hidden">
                    <h3>‚ûï Cr√©er une √âquipe</h3>
                    <label>Nom de l'√©quipe *</label>
                    <input type="text" id="teamName" placeholder="Les champions" />

                    <label>Ton pseudo *</label>
                    <input type="text" id="teamPlayerPseudo" placeholder="Ton pseudo" />

                    <label>Mot de passe (6 chiffres) *</label>
                    <div class="password-container">
                        <input type="password" id="teamPassword" placeholder="123456" maxlength="6"
                               inputmode="numeric" pattern="[0-9]*"
                               oninput="this.value = this.value.replace(/[^0-9]/g, '')" />
                        <button type="button" class="password-toggle"
                                onclick="togglePassword('teamPassword', this)">üëÅÔ∏è</button>
                    </div>

                    <button class="btn btn-success" style="width: 100%; margin-top: 15px;"
                            onclick="hdnApp.createTeam()">
                        üéØ Cr√©er l'√©quipe
                    </button>
                    <button class="btn btn-primary" style="width: 100%; margin-top: 10px;"
                            onclick="hdnApp.backToTeamAction()">
                        ‚Üê Retour
                    </button>
                </div>

                <!-- Join Team Form (hidden) -->
                <div id="joinTeamForm" class="hidden">
                    <h3>üîó Rejoindre une √âquipe</h3>
                    <label>Code de l'√©quipe *</label>
                    <input type="text" id="teamCode" placeholder="Ex: HDN-ABC123" />

                    <label>Ton pseudo *</label>
                    <input type="text" id="joinTeamPseudo" placeholder="Ton pseudo" />

                    <label>Mot de passe (6 chiffres) *</label>
                    <div class="password-container">
                        <input type="password" id="joincreateTeamPassword" placeholder="123456" maxlength="6"
                               inputmode="numeric" pattern="[0-9]*"
                               oninput="this.value = this.value.replace(/[^0-9]/g, '')" />
                        <button type="button" class="password-toggle"
                                onclick="togglePassword('joincreateTeamPassword', this)">üëÅÔ∏è</button>
                    </div>

                    <button class="btn btn-success" style="width: 100%; margin-top: 15px;" onclick="hdnApp.joinTeam()">
                        üöÄ Rejoindre
                    </button>
                    <button class="btn btn-primary" style="width: 100%; margin-top: 10px;"
                            onclick="hdnApp.backToTeamAction()">
                        ‚Üê Retour
                    </button>
                </div>
            </div>
        </div>

        <!-- HOME SECTION -->
        <div class="section" id="home-section">
            <div class="card">
                <h2>üè† Tableau de bord</h2>

                <!-- Countdown Timer -->
                <div class="timer" id="countdownTimer">
                    <p>‚è≥ Aucune √©nigme programm√©e</p>
                </div>

                <!-- User Stats -->
                <div class="stats-grid">
                    <div class="stat-box">
                        <h3 id="userPoints">0</h3>
                        <p>Points</p>
                    </div>
                    <div class="stat-box">
                        <h3 id="userSolved">0</h3>
                        <p>√ânigmes r√©solues</p>
                    </div>
                    <div class="stat-box">
                        <h3 id="userRank">-</h3>
                        <p>Classement</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- ENIGMES SECTION -->
        <div class="section" id="enigmes-section">
            <div class="card">
                <h2>üí° √ânigmes</h2>
                <div id="enigmesList" class="loading">Chargement...</div>
            </div>
        </div>

        <!-- RANKING SECTION -->
        <div class="section" id="ranking-section">
            <div class="card">
                <h2>üèÜ Classement</h2>
                <div id="rankingList" class="loading">Chargement...</div>
            </div>
        </div>

        <!-- RULES SECTION -->
        <div class="section" id="rules-section">
            <div class="card">
                <h2>üìã R√®gles du Jeu</h2>

                <h3>üéØ Objectif</h3>
                <p>R√©soudre un maximum d'√©nigmes pour accumuler des points et grimper dans le classement !</p>

                <h3>üéÆ Comment jouer</h3>
                <ul style="margin-left: 20px; line-height: 2;">
                    <li>R√©solvez l'√©nigme et soumettez votre r√©ponse</li>
                    <li>La soumission des √©ngimes se fait uniquement entre 12h et 14h en semaine. (Si l'envie vous
                        prends, vous pouvez jouer le weekend sans probl√®me)</li>
                    <li>Une fois valid√©e, l'emplacement du QR code est r√©v√©l√©</li>
                    <li>Scannez le QR code pour gagner vos points !</li>
                </ul>

                <h3>üíé Syst√®me de Points</h3>
                <ul style="margin-left: 20px; line-height: 2;">
                    <li><strong>1√®re place :</strong> 200 points ü•á</li>
                    <li><strong>2√®me place :</strong> 150 points ü•à</li>
                    <li><strong>3√®me place :</strong> 100 points ü•â</li>
                    <li><strong>4√®me+ :</strong> 50 points</li>
                    <li>‚ö†Ô∏è Les points sont calcul√©s AU MOMENT o√π tu scannes le QR code !</li>
                    <li>üí° Tu ne connais tes points qu'APR√àS avoir scann√© le QR</li>
                </ul>

                <h3>üí° Indices</h3>
                <ul style="margin-left: 20px; line-height: 2;">
                    <li>3 indices disponibles par √©nigme</li>
                    <li>Le 1er indice co√ªte <strong>5 points</strong></li>
                    <li>Le 2√®me indice co√ªte <strong>15 points</strong></li>
                    <li>Le 3√®me indice co√ªte <strong>30 points</strong></li>
                    <li>Les indices se d√©bloquent progressivement</li>
                </ul>

                <h3>üîí Lockout</h3>
                <ul style="margin-left: 20px; line-height: 2;">
                    <li>Apr√®s <strong>3 mauvaises r√©ponses</strong>, l'√©nigme est bloqu√©e</li>
                    <li>Temps de blocage : <strong>15 minutes</strong></li>
                    <li>Je vous conseil donc de bien r√©fl√©chir avant de soumettre votre r√©ponse</li>
                </ul>

                <h3>üë• Mode √âquipe</h3>
                <ul style="margin-left: 20px; line-height: 2;">
                    <li>Les points sont partag√©s entre les membres</li>
                    <li>Si un membre de l'√©quipe valide l'√©nigme, elle se valdie aussi pour les autres membres</li>
                    <li>De la m√™me fa√ßon, si un membre de l'√©quipe demande un indice, il s'affiche pour tous les membres
                    </li>
                    <li>Vous pouvez voir les performances individuelles dans vos statistiques de compte</li>
                </ul>

                <h3>üì± QR Codes</h3>
                <ul style="margin-left: 20px; line-height: 2;">
                    <li>Apr√®s validation de la r√©ponse, l'emplacement du QR est r√©v√©l√©</li>
                    <li>Trouvez et scannez le QR code pour gagner vos points (Si vous trouvez un autre QR Code, inutile
                        de le scanner, c'est un QR code unique par √©nigme üòã)</li>
                    <li>C'est une course ! Le premier √† scanner gagne le plus de points !</li>
                </ul>

                <div class="alert alert-info" style="margin-top: 20px;">
                    <strong>üìÖ Dates importantes :</strong><br>
                    ‚Ä¢ D√©but : 25 novembre 2025<br>
                    ‚Ä¢ Fin : 08 d√©cembre 2025<br>
                </div>
            </div>
        </div>

        <!-- ADMIN SECTION -->
        <div class="section" id="admin-section">
            <div class="card">
                <h2>‚öôÔ∏è Administration</h2>

                <h3>üìä Statistiques</h3>
                <div class="stats-grid">
                    <div class="stat-box">
                        <h3 id="adminTotalPlayers">0</h3>
                        <p>Joueurs</p>
                    </div>
                    <div class="stat-box">
                        <h3 id="adminTotalEnigmas">0</h3>
                        <p>√ânigmes</p>
                    </div>
                    <div class="stat-box">
                        <h3 id="adminPendingValidations">0</h3>
                        <p>En attente</p>
                    </div>
                </div>

                <h3>‚ûï Cr√©er une √ânigme</h3>

                <label>Titre *</label>
                <input type="text" id="enigmaTitle" placeholder="Titre de l'√©nigme" />

                <label>Description *</label>
                <textarea id="enigmaDescription" rows="4" placeholder="√ânonc√© de l'√©nigme"></textarea>

                <label>Image (URL optionnelle)</label>
                <input type="url" id="enigmaImageUrl" placeholder="https://example.com/image.jpg" />
                <p style="font-size: 0.85em; color: #666; margin-top: 5px;">
                    URL de l'image √† afficher avec l'√©nigme (optionnel)
                </p>

                <label>R√©ponse *</label>
                <input type="text" id="enigmaAnswer" placeholder="R√©ponse correcte" />

                <label>Emplacement du QR Code *</label>
                <input type="text" id="enigmaLocation" placeholder="Ex: Pr√®s de la fontaine, 2√®me √©tage..." />

                <label>Type de validation</label>
                <select id="enigmaValidation">
                    <option value="auto">Automatique</option>
                    <option value="manual">Manuelle</option>
                </select>

                <h3>üí° Indices (optionnels)</h3>
                <label>Indice 1</label>
                <textarea id="enigmaHint1" rows="2" placeholder="Premier indice (-5 points)"></textarea>

                <label>Indice 2</label>
                <textarea id="enigmaHint2" rows="2" placeholder="Deuxi√®me indice (-15 points)"></textarea>

                <label>Indice 3</label>
                <textarea id="enigmaHint3" rows="2" placeholder="Troisi√®me indice (-30 points)"></textarea>

                <h3>üìÖ Publication</h3>
                <label>
                    <input type="checkbox" id="enigmaPublished" style="width: auto; margin-right: 10px;" />
                    Publier imm√©diatement
                </label>

                <div id="schedulePublishDiv" style="margin-top: 15px;">
                    <label>üìÖ Programmer la publication (optionnel)</label>
                    <input type="datetime-local" id="enigmaSchedule" />
                    <p style="font-size: 0.85em; color: #666; margin-top: 5px;">
                        Si rempli, l'√©nigme sera automatiquement publi√©e √† cette date/heure
                    </p>
                </div>

                <button class="btn btn-success" style="width: 100%; margin-top: 15px;" onclick="hdnApp.createEnigma()">
                    ‚úÖ Cr√©er l'√©nigme
                </button>

                <h3 style="margin-top: 30px;">üìã Mes √ânigmes</h3>
                <div id="adminEnigmasList"></div>

                <h3 style="margin-top: 30px;">‚úÖ Validations en attente</h3>
                <div id="pendingValidationsList"></div>

                <h3 style="margin-top: 30px;">üíæ Export des donn√©es</h3>
                <button class="btn btn-primary" style="width: 100%;" onclick="hdnApp.exportData()">
                    üì• Exporter toutes les donn√©es
                </button>
            </div>
        </div>
    </div>

    <script>
        // Configuration Supabase
        const SUPABASE_URL = 'https://kjziudxhzbwhhnwvmlkt.supabase.co';
        const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imtqeml1ZHhoemJ3aGhud3ZtbGt0Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjMzOTg1MTIsImV4cCI6MjA3ODk3NDUxMn0.clKFjIPw6bO_-VI5epj1Fg7TlXUAAeqgYH4bCMS-uP4';

        // Initialize Supabase client
        const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);

        // Toggle password visibility
        function togglePassword(inputId, button) {
            const input = document.getElementById(inputId);
            if (input.type === 'password') {
                input.type = 'text';
                button.textContent = 'üôà';
            } else {
                input.type = 'password';
                button.textContent = 'üëÅÔ∏è';
            }
        }

        // Toast Notification System
        function showToast(message, type = 'info') {
            // Remove existing toast if any
            const existing = document.querySelector('.toast');
            if (existing) existing.remove();

            // Create toast
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            document.body.appendChild(toast);

            // Auto remove after 4 seconds
            setTimeout(() => {
                toast.style.animation = 'slideUp 0.3s ease-out reverse';
                setTimeout(() => toast.remove(), 300);
            }, 4000);
        }

        // Timezone helper - Convert UTC to Paris time
        function toParisTime(utcDateString) {
            if (!utcDateString) return null;
            const date = new Date(utcDateString);
            return new Date(date.toLocaleString('en-US', { timeZone: 'Europe/Paris' }));
        }

        function formatParisDateTime(utcDateString) {
            if (!utcDateString) return '';
            const date = toParisTime(utcDateString);
            return date.toLocaleString('fr-FR', {
                day: '2-digit',
                month: '2-digit',
                year: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            });
        }

        // ========== SECURITY: Password Hashing ==========
        async function hashPassword(password) {
            const encoder = new TextEncoder();
            const data = encoder.encode(password + 'HDN_SALT_2025');
            const hashBuffer = await crypto.subtle.digest('SHA-256', data);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
        }

        // Main Application
        const hdnApp = {
            currentUser: null,
            selectedMode: null,
            selectedTeamAction: null,
            qrScanner: null,
            countdownInterval: null,
            currentScanEnigmaId: null,

            // Helper to convert local datetime to UTC ISO string
            convertLocalToUTC(localDatetimeString) {
                if (!localDatetimeString) return null;
                const localDate = new Date(localDatetimeString);
                return localDate.toISOString();
            },

            // Check if enigmas are accessible (12h-14h weekdays, 24/7 weekend)
            isEnigmaAccessAllowed() {
                // Admin can always access
                if (this.currentUser?.is_admin) return true;

                const now = new Date();
                const dayOfWeek = now.getDay();
                const hours = now.getHours();

                // Weekend = toujours accessible
                // if (dayOfWeek === 0 || dayOfWeek === 6) {
                //     return true;
                // }

                // Semaine = 12h-14h uniquement
                return hours >= 12 && hours < 22;
            },

            // Update enigma button state
            updateEnigmaButtonState() {

                const enigmaBtn = document.getElementById('enigmaNavBtn');
                console.log('Bouton trouv√©:', enigmaBtn);

                if (!enigmaBtn) {
                    console.error('‚ùå Bouton √ânigmes non trouv√© !');
                    return;
                }

                const isAllowed = this.isEnigmaAccessAllowed();
                console.log('Acc√®s autoris√©:', isAllowed);

                if (isAllowed) {
                    console.log('‚úÖ D√©verrouillage du bouton');
                    // D√©verrouiller
                    enigmaBtn.disabled = false;
                    enigmaBtn.style.opacity = '1';
                    enigmaBtn.style.cursor = 'pointer';
                    enigmaBtn.onclick = () => this.showSection('enigmes');
                } else {
                    console.log('üîí Verrouillage du bouton');
                    // Verrouiller
                    enigmaBtn.disabled = true;
                    enigmaBtn.style.opacity = '0.5';
                    enigmaBtn.style.cursor = 'not-allowed';
                    enigmaBtn.style.pointerEvents = 'auto';
                    enigmaBtn.onclick = (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        showToast('‚è∞ Les √©nigmes sont accessibles uniquement entre 12h et 14h en semaine !', 'warning');
                    };
                }



                console.log('√âtat final du bouton:', {
                    disabled: enigmaBtn.disabled,
                    opacity: enigmaBtn.style.opacity,
                    cursor: enigmaBtn.style.cursor
                });
            },

            showRulesModal() {
                // Create modal
                const modal = document.createElement('div');
                modal.className = 'rules-modal';
                modal.onclick = (e) => {
                    if (e.target === modal) this.closeRulesModal();
                };

                modal.innerHTML = `
        <div class="rules-modal-content">
            <button class="rules-modal-close" onclick="hdnApp.closeRulesModal()">√ó</button>
            <div id="modalRulesContent"></div>
        </div>
    `;

                document.body.appendChild(modal);

                // Copy rules content
                const rulesSection = document.getElementById('rules-section');
                const modalContent = document.getElementById('modalRulesContent');
                modalContent.innerHTML = rulesSection.innerHTML;
            },

            closeRulesModal() {
                const modal = document.querySelector('.rules-modal');
                if (modal) {
                    modal.remove();
                }
            },

            async init() {
                console.log('üéÑ HDN Christmas App Starting...');

                // Check if user is logged in
                const savedUser = localStorage.getItem('hdnCurrentUser');
                if (savedUser) {
                    this.currentUser = JSON.parse(savedUser);
                    await this.loadUserData();
                    this.showMainApp();
                }

                // Start countdown timer
                this.startCountdown();
            },

            // ========== AUTH FLOW ==========

            showLogin() {
                document.getElementById('authChoice').classList.add('hidden');
                document.getElementById('loginForm').classList.remove('hidden');
            },

            showRegister() {
                document.getElementById('authChoice').classList.add('hidden');
                document.getElementById('registerChoice').classList.remove('hidden');
            },

            backToChoice() {
                document.getElementById('loginForm').classList.add('hidden');
                document.getElementById('registerChoice').classList.add('hidden');
                document.getElementById('authChoice').classList.remove('hidden');

                // Clear fields
                document.getElementById('loginPseudo').value = '';
                document.getElementById('loginPassword').value = '';
            },

            backToRegisterChoice() {
                document.getElementById('soloForm').classList.add('hidden');
                document.getElementById('teamActionSelection').classList.add('hidden');
                document.getElementById('registerChoice').classList.remove('hidden');
                // Clear fields
                document.getElementById('soloPseudo').value = '';
                document.getElementById('soloPassword').value = '';
            },

            backToTeamAction() {
                document.getElementById('createTeamForm').classList.add('hidden');
                document.getElementById('joinTeamForm').classList.add('hidden');
                document.getElementById('teamActionSelection').classList.remove('hidden');
            },

            selectMode(mode) {
                this.selectedMode = mode;

                // Update UI
                document.querySelectorAll('#registerChoice .radio-option').forEach(opt => {
                    opt.classList.remove('active');
                });
                event.target.closest('.radio-option').classList.add('active');

                // Show appropriate form
                if (mode === 'solo') {
                    document.getElementById('registerChoice').classList.add('hidden');
                    document.getElementById('soloForm').classList.remove('hidden');
                    document.getElementById('teamActionSelection').classList.add('hidden');
                } else if (mode === 'team') {
                    document.getElementById('registerChoice').classList.add('hidden');
                    document.getElementById('teamActionSelection').classList.remove('hidden');
                    document.getElementById('soloForm').classList.add('hidden');
                }
            },

            selectTeamAction(action) {
                this.selectedTeamAction = action;

                // Update UI
                document.querySelectorAll('#teamActionSelection .radio-option').forEach(opt => {
                    opt.classList.remove('active');
                });
                event.target.closest('.radio-option').classList.add('active');

                // Show appropriate form
                setTimeout(() => {
                    document.getElementById('teamActionSelection').classList.add('hidden');
                    if (action === 'create') {
                        document.getElementById('createTeamForm').classList.remove('hidden');
                    } else {
                        document.getElementById('joinTeamForm').classList.remove('hidden');
                    }
                }, 200);
            },

            // ========== REGISTRATION ==========

            async registerSolo() {
                const pseudo = document.getElementById('soloPseudo').value.trim();
                const password = document.getElementById('soloPassword').value;

                if (!pseudo || !password) {
                    showToast('Veuillez remplir tous les champs', 'error');
                    return;
                }

                if (password.length !== 6 || !/^\d+$/.test(password)) {
                    showToast('Le mot de passe doit contenir exactement 6 chiffres', 'error');
                    return;
                }

                try {
                    // Hash password before storing
                    const hashedPassword = await hashPassword(password);

                    // Cr√©er le joueur avec type 'solo'
                    const { data: player, error: playerError } = await supabase
                        .from('players')
                        .insert([{
                            pseudo: pseudo,
                            password: hashedPassword,
                            type: 'solo',
                            points: 0,
                            is_test: false
                        }])
                        .select('id, pseudo, type, points, team_id, is_admin, is_test')
                        .single();

                    if (playerError) throw playerError;

                    // Stocker les infos et se connecter
                    localStorage.setItem('playerId', player.id);
                    localStorage.setItem('playerPseudo', player.pseudo);
                    localStorage.setItem('playerType', 'solo');

                    // Stocker la session et se connecter
                    this.currentUser = player;
                    localStorage.setItem('hdnCurrentUser', JSON.stringify(player));

                    showToast('Inscription r√©ussie ! Bienvenue ' + player.pseudo + ' !', 'success');

                    await this.loadUserData();
                    this.showMainApp();

                } catch (error) {
                    console.error('Erreur inscription solo:', error);
                    if (error.code === '23505') {
                        showToast('Ce pseudo est d√©j√† utilis√©', 'error');
                    } else {
                        showToast('Erreur lors de l\'inscription : ' + error.message, 'error');
                    }
                }
            },

            async createTeam() {
                const teamName = document.getElementById('teamName').value.trim();
                const playerPseudo = document.getElementById('teamPlayerPseudo').value.trim();
                const password = document.getElementById('teamPassword').value;

                if (!teamName || !playerPseudo || !password) {
                    showToast('Veuillez remplir tous les champs', 'error');
                    return;
                }

                if (password.length !== 6 || !/^\d+$/.test(password)) {
                    showToast('Le mot de passe doit contenir exactement 6 chiffres', 'error');
                    return;
                }

                try {
                    // V√©rifier si le pseudo existe d√©j√†
                    const { data: existing } = await supabase
                        .from('players')
                        .select('id')
                        .eq('pseudo', playerPseudo)
                        .maybeSingle();

                    if (existing) {
                        showToast('‚ùå Ce pseudo existe d√©j√† !', 'error');
                        return;
                    }

                    // G√©n√©rer un code unique pour l'√©quipe
                    const teamCode = Math.random().toString(36).substring(2, 8).toUpperCase();

                    // Hash password before storing
                    const hashedPassword = await hashPassword(password);

                    // 1. Cr√©er le joueur SANS team_id d'abord
                    const { data: player, error: playerError } = await supabase
                        .from('players')
                        .insert([{
                            pseudo: playerPseudo,
                            password: hashedPassword,
                            type: 'team',
                            team_id: null,
                            points: 0,
                            is_admin: false,
                            is_test: false
                        }])
                        .select('id, pseudo, type, points, team_id, is_admin, is_test')
                        .single();

                    if (playerError) throw playerError;

                    // 2. Cr√©er l'√©quipe avec le leader
                    const { data: team, error: teamError } = await supabase
                        .from('teams')
                        .insert([{
                            name: teamName,
                            code: teamCode,
                            leader: player.id
                        }])
                        .select()
                        .single();

                    if (teamError) {
                        // Si erreur, supprimer le joueur cr√©√©
                        await supabase.from('players').delete().eq('id', player.id);
                        throw teamError;
                    }

                    // 3. Mettre √† jour le joueur avec team_id
                    const { error: updateError } = await supabase
                        .from('players')
                        .update({ team_id: team.id })
                        .eq('id', player.id);

                    if (updateError) {
                        // Nettoyer si erreur
                        await supabase.from('teams').delete().eq('id', team.id);
                        await supabase.from('players').delete().eq('id', player.id);
                        throw updateError;
                    }

                    // Mettre √† jour l'objet player localement
                    player.team_id = team.id;

                    // Stocker la session
                    this.currentUser = player;
                    localStorage.setItem('hdnCurrentUser', JSON.stringify(player));

                    showToast('‚úÖ √âquipe cr√©√©e ! Code : ' + team.code, 'success');

                    await this.loadUserData();
                    this.showMainApp();

                } catch (error) {
                    console.error('Erreur cr√©ation √©quipe:', error);
                    if (error.code === '23505') {
                        showToast('‚ùå Ce pseudo est d√©j√† utilis√©', 'error');
                    } else {
                        showToast('‚ùå Erreur lors de la cr√©ation : ' + error.message, 'error');
                    }
                }
            },

            async joinTeam() {
                const teamCode = document.getElementById('teamCode').value.trim();
                const pseudo = document.getElementById('joinTeamPseudo').value.trim();
                const password = document.getElementById('joincreateTeamPassword').value.trim();

                if (!teamCode || !pseudo || !password) {
                    showToast('‚ùå Remplis tous les champs !', 'error');
                    return;
                }

                if (password.length !== 6 || !/^\d{6}$/.test(password)) {
                    showToast('‚ùå Le mot de passe doit contenir exactement 6 chiffres !', 'error');
                    return;
                }

                try {
                    // Find team (only get non-sensitive columns)
                    const { data: team, error: teamError } = await supabase
                        .from('teams')
                        .select('id, name, code, points')
                        .eq('code', teamCode.toUpperCase())
                        .maybeSingle();

                    if (!team) {
                        showToast('‚ùå Code d\'√©quipe invalide !', 'error');
                        return;
                    }

                    // Check if pseudo exists
                    const { data: existing } = await supabase
                        .from('players')
                        .select('id')
                        .eq('pseudo', pseudo)
                        .maybeSingle();

                    if (existing) {
                        showToast('‚ùå Ce pseudo existe d√©j√† !', 'error');
                        return;
                    }

                    // Hash password before storing
                    const hashedPassword = await hashPassword(password);

                    // Create player
                    const { data: player, error: playerError } = await supabase
                        .from('players')
                        .insert([{
                            pseudo: pseudo,
                            password: hashedPassword,
                            team_id: team.id,
                            points: 0,
                            is_admin: false,
                            is_test: false,
                            type: 'team'
                        }])
                        .select('id, pseudo, type, points, team_id, is_admin, is_test')
                        .single();

                    if (playerError) throw playerError;

                    showToast(`‚úÖ Tu as rejoint l'√©quipe "${team.name}" !`, 'success');

                    // Auto login
                    this.currentUser = player;
                    localStorage.setItem('hdnCurrentUser', JSON.stringify(player));
                    await this.loadUserData();
                    this.showMainApp();

                } catch (error) {
                    console.error('Error:', error);
                    showToast('‚ùå Erreur lors de la connexion √† l\'√©quipe : ' + error.message, 'error');
                }
            },

            // ========== LOGIN ==========

            async login() {
                const pseudo = document.getElementById('loginPseudo').value.trim();
                const password = document.getElementById('loginPassword').value.trim();

                if (!pseudo || !password) {
                    showToast('‚ùå Remplis tous les champs !', 'error');
                    return;
                }

                try {
                    // Hash password before comparing
                    const hashedPassword = await hashPassword(password);

                    const { data: player, error } = await supabase
                        .from('players')
                        .select('id, pseudo, type, points, team_id, is_admin, is_test')
                        .eq('pseudo', pseudo)
                        .eq('password', hashedPassword)
                        .maybeSingle();

                    if (!player) {
                        showToast('‚ùå Pseudo ou mot de passe incorrect !', 'error');
                        return;
                    }

                    // Login successful
                    this.currentUser = player;
                    localStorage.setItem('hdnCurrentUser', JSON.stringify(player));
                    await this.loadUserData();
                    this.showMainApp();

                    showToast('‚úÖ Connexion r√©ussie !', 'success');

                } catch (error) {
                    console.error('Error:', error);
                    showToast('‚ùå Erreur lors de la connexion', 'error');
                }
            },

            // ========== USER DATA ==========

            async loadUserData() {
                if (!this.currentUser) return;

                try {
                    // Reload fresh user data (without password)
                    const { data: player } = await supabase
                        .from('players')
                        .select('id, pseudo, type, points, team_id, is_admin, is_test')
                        .eq('id', this.currentUser.id)
                        .maybeSingle();

                    if (player) {
                        this.currentUser = player;
                        localStorage.setItem('hdnCurrentUser', JSON.stringify(player));
                    }

                    // Update UI
                    document.getElementById('userPseudo').textContent = this.currentUser.pseudo;
                    document.getElementById('userPoints').textContent = this.currentUser.points || 0;

                    // Load team info if applicable (without sensitive data)
                    if (this.currentUser.team_id) {
                        const { data: team } = await supabase
                            .from('teams')
                            .select('id, name, code, points')
                            .eq('id', this.currentUser.team_id)
                            .maybeSingle();

                        if (team) {
                            document.getElementById('userTeamInfo').textContent = `√âquipe: ${team.name} - Code: ${team.code}`;
                        }
                    } else {
                        document.getElementById('userTeamInfo').textContent = 'Solo';
                    }

                    // Load solved enigmas count
                    let query = supabase
                        .from('enigma_progress')
                        .select('id', { count: 'exact' })
                        .eq('solved', true);

                    if (this.currentUser.team_id) {
                        query = query.eq('team_id', this.currentUser.team_id);
                    } else {
                        query = query.eq('player_id', this.currentUser.id);
                    }

                    const { count } = await query;
                    document.getElementById('userSolved').textContent = count || 0;

                    // Calculate rank
                    await this.calculateRank();

                } catch (error) {
                    console.error('Error loading user data:', error);
                }
            },

            async calculateRank() {
                try {
                    // Get all non-test players/teams ranked by points
                    if (this.currentUser.team_id) {
                        // Team ranking
                        const { data: teams } = await supabase
                            .from('teams')
                            .select('id, points')
                            .order('points', { ascending: false });

                        const rank = teams.findIndex(t => t.id === this.currentUser.team_id) + 1;
                        document.getElementById('userRank').textContent = rank > 0 ? rank : '-';
                    } else {
                        // Solo ranking (exclude test accounts)
                        const { data: players } = await supabase
                            .from('players')
                            .select('id, points, is_test')
                            .is('team_id', null)
                            .eq('is_test', false)
                            .order('points', { ascending: false });

                        const rank = players.findIndex(p => p.id === this.currentUser.id) + 1;
                        document.getElementById('userRank').textContent = rank > 0 ? rank : '-';
                    }
                } catch (error) {
                    console.error('Error calculating rank:', error);
                }
            },

            showMainApp() {
                // Hide auth section
                document.getElementById('auth-section').classList.remove('active');

                // Show user info and nav
                document.getElementById('userInfo').classList.remove('hidden');
                document.getElementById('mainNav').classList.remove('hidden');

                // Show admin button if admin
                if (this.currentUser.is_admin) {
                    document.getElementById('adminNavBtn').classList.remove('hidden');
                    // Hide floating rules button
                    const floatingRulesBtn = document.querySelector('.floating-rules-btn');
                    if (floatingRulesBtn) {
                        floatingRulesBtn.style.display = 'none';
                    }
                }

                // Show home section
                this.showSection('home');
            },

            logout() {
                if (confirm('Veux-tu vraiment te d√©connecter ?')) {
                    localStorage.removeItem('hdnCurrentUser');
                    location.reload();
                }
            },

            // ========== NAVIGATION ==========

            showSection(sectionName) {
                // Check enigma access
                if (sectionName === 'enigmes' && !this.isEnigmaAccessAllowed()) {
                    showToast('‚è∞ En semaine les √©nigmes sont accessibles uniquement entre 12h et 14h !', 'warning');
                    return;
                }

                // Hide all sections
                document.querySelectorAll('.section').forEach(section => {
                    section.classList.remove('active');
                });

                // Remove active class from all nav buttons
                document.querySelectorAll('nav button').forEach(btn => {
                    btn.classList.remove('active');
                });

                // Show selected section
                document.getElementById(`${sectionName}-section`).classList.add('active');

                // Highlight active nav button
                event?.target?.classList.add('active');

                // Load section data
                if (sectionName === 'enigmes') {
                    this.loadEnigmes();
                } else if (sectionName === 'ranking') {
                    this.loadClassement();
                } else if (sectionName === 'admin') {
                    this.loadAdminPanel();
                } else if (sectionName === 'home') {
                    this.loadUserData();
                }
            },

            // ========== COUNTDOWN TIMER ==========

            startCountdown() {
                if (this.countdownInterval) {
                    clearInterval(this.countdownInterval);
                }

                this.updateCountdown();
                this.countdownInterval = setInterval(() => this.updateCountdown(), 1000);
            },

            async updateCountdown() {
                try {
                    // Get next scheduled enigma (without sensitive data)
                    const { data: nextEnigma } = await supabase
                        .from('enigmas')
                        .select('id, number, title, scheduled_at, published')
                        .eq('published', false)
                        .not('scheduled_at', 'is', null)
                        .order('scheduled_at', { ascending: true })
                        .limit(1)
                        .maybeSingle();

                    const timerDiv = document.getElementById('countdownTimer');

                    if (!nextEnigma) {
                        timerDiv.innerHTML = '<p>‚è≥ Aucune √©nigme programm√©e</p>';
                        return;
                    }

                    // Use Paris timezone
                    const now = new Date();
                    const target = toParisTime(nextEnigma.scheduled_at);
                    const diff = target - now;

                    if (diff <= 0) {
                        // Enigma should be published now
                        timerDiv.innerHTML = '<p>üöÄ Nouvelle √©nigme disponible !</p>';

                        // Auto-publish if not yet published
                        if (!nextEnigma.published) {
                            await supabase
                                .from('enigmas')
                                .update({ published: true })
                                .eq('id', nextEnigma.id);

                            // Reload enigmas if on that page
                            const enigmesSection = document.getElementById('enigmes-section');
                            if (enigmesSection && enigmesSection.classList.contains('active')) {
                                this.loadEnigmes();
                            }
                        }
                        return;
                    }

                    // Calculate time remaining
                    const days = Math.floor(diff / (1000 * 60 * 60 * 24));
                    const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
                    const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
                    const seconds = Math.floor((diff % (1000 * 60)) / 1000);

                    let timeString = '';
                    if (days > 0) timeString += `${days}j `;
                    timeString += `${hours}h ${minutes}m ${seconds}s`;

                    timerDiv.innerHTML = `
                        <p style="font-size: 1em; margin-bottom: 10px;">Prochaine √©nigme :</p>
                        <p style="font-size: 0.9em; opacity: 0.8; margin-bottom: 5px;">${nextEnigma.title}</p>
                        <h2>${timeString}</h2>
                    `;

                } catch (error) {
                    console.error('Error updating countdown:', error);
                }
            },

            // ========== ENIGMES ==========

            async loadEnigmes() {
                const container = document.getElementById('enigmesList');
                container.innerHTML = '<div class="loading">Chargement des √©nigmes...</div>';

                try {
                    // Get published enigmas WITHOUT sensitive data (answer, qr_secret)
                    const { data: enigmas } = await supabase
                        .from('enigmas')
                        .select('id, number, title, description, image_url, location, validation_type, hint1, hint2, hint3, published, scheduled_at')
                        .eq('published', true)
                        .order('number', { ascending: true });

                    if (!enigmas || enigmas.length === 0) {
                        container.innerHTML = '<p style="text-align: center; color: #666;">Aucune √©nigme disponible pour le moment.</p>';
                        return;
                    }

                    container.innerHTML = '';

                    for (const enigma of enigmas) {
                        // Get progress
                        const progress = await this.getProgress(enigma.id);
                        const lockStatus = this.isLocked(progress);

                        const enigmeDiv = document.createElement('div');
                        enigmeDiv.className = 'enigme-item';
                        if (progress && progress.solved) enigmeDiv.classList.add('solved');
                        if (lockStatus.locked) enigmeDiv.classList.add('locked');

                        let content = `<h3>√ânigme #${enigma.number} - ${enigma.title}</h3>`;

                        // Show lock timer if locked
                        if (lockStatus.locked) {
                            content += `
                    <div class="lockout-timer">
                        <h3>üîí Bloqu√©</h3>
                        <p>Temps restant : ${lockStatus.remaining} minutes</p>
                    </div>
                `;
                        }

                        content += `<p>${enigma.description}</p>`;

                        // Show image if available
                        if (enigma.image_url) {
                            content += `<img src="${enigma.image_url}" class="enigme-image" alt="Image de l'√©nigme" onerror="this.style.display='none'" />`;
                        }

                        // Answer form or solved status
                        if (progress && progress.solved) {
                            content += `<div class="alert alert-success">‚úÖ √ânigme r√©solue !</div>`;

                            // QR Code section
                            if (enigma.qr_secret) {
                                content += `<div class="alert alert-info">üìç <strong>Emplacement du QR Code :</strong> ${enigma.location}</div>`;

                                if (progress.qr_scanned) {
                                    content += `<div class="alert alert-success">‚úÖ QR Code scann√© ! +${progress.points_earned || 0} points</div>`;
                                } else {
                                    content += `<div class="alert alert-warning">‚ö†Ô∏è Scanne le QR code pour gagner tes points !</div>`;
                                    content += `<button class="btn btn-primary" onclick="hdnApp.openQRScanner(${enigma.id})">üì± Scanner le QR Code</button>`;
                                }
                            }
                        } else if (!lockStatus.locked) {
                            // Hints section - Only show if NOT solved
                            if (enigma.hint1 || enigma.hint2 || enigma.hint3) {
                                content += '<div class="hints-section"><h4>üí° Indices</h4>';

                                if (enigma.hint1) {
                                    const hint1Used = progress?.hints_used?.includes(1);
                                    // Indice 1 : JAMAIS locked
                                    content += `<div class="hint-item">`;
                                    content += hint1Used
                                        ? `<p><strong>Indice 1 :</strong> ${enigma.hint1}</p>`
                                        : `<button class="btn btn-warning" onclick="hdnApp.requestHint(${enigma.id}, 1)">üîì Indice 1 (-5 points)</button>`;
                                    content += '</div>';
                                }

                                if (enigma.hint2) {
                                    const hint1Used = progress?.hints_used?.includes(1);
                                    const hint2Used = progress?.hints_used?.includes(2);
                                    // Indice 2 : locked si indice 1 pas pris
                                    content += `<div class="hint-item ${!hint1Used ? 'locked' : ''}">`;
                                    content += hint2Used
                                        ? `<p><strong>Indice 2 :</strong> ${enigma.hint2}</p>`
                                        : `<button class="btn btn-warning" onclick="hdnApp.requestHint(${enigma.id}, 2)" ${!hint1Used ? 'disabled' : ''}>üîì Indice 2 (-15 points)</button>`;
                                    content += '</div>';
                                }

                                if (enigma.hint3) {
                                    const hint2Used = progress?.hints_used?.includes(2);
                                    const hint3Used = progress?.hints_used?.includes(3);
                                    // Indice 3 : locked si indice 2 pas pris
                                    content += `<div class="hint-item ${!hint2Used ? 'locked' : ''}">`;
                                    content += hint3Used
                                        ? `<p><strong>Indice 3 :</strong> ${enigma.hint3}</p>`
                                        : `<button class="btn btn-warning" onclick="hdnApp.requestHint(${enigma.id}, 3)" ${!hint2Used ? 'disabled' : ''}>üîì Indice 3 (-30 points)</button>`;
                                    content += '</div>';
                                }

                                content += '</div>';
                            }

                            // Check for pending submission - Fixed query
                            let submissionQuery = supabase
                                .from('submissions')
                                .select('*')
                                .eq('enigma_id', enigma.id)
                                .eq('status', 'pending');

                            if (this.currentUser.team_id) {
                                submissionQuery = submissionQuery.eq('team_id', this.currentUser.team_id);
                            } else {
                                submissionQuery = submissionQuery.eq('player_id', this.currentUser.id);
                            }

                            const { data: pendingSubmission } = await submissionQuery.maybeSingle();

                            if (pendingSubmission) {
                                // Show pending validation message
                                content += `
                        <div class="alert alert-info" style="background: #fff3cd; border-left: 4px solid #ffaa00; padding: 15px; margin-top: 15px;">
                            <h4 style="color: #856404; margin: 0 0 10px 0;">‚è≥ En attente de validation par HDN</h4>
                            <p style="color: #856404; margin: 0;">
                                <strong>Ta r√©ponse :</strong> ${pendingSubmission.answer}<br>
                                Ton admin va valider ta r√©ponse bient√¥t !
                            </p>
                        </div>
                    `;
                            } else {
                                // Show answer form
                                content += `
                        <div style="margin-top: 15px;">
                            <label>Ta r√©ponse :</label>
                            <input type="text" id="answer-${enigma.id}" placeholder="Ta r√©ponse..." />
                            <button class="btn btn-success" style="width: 100%; margin-top: 10px;" 
                                    onclick="hdnApp.submitAnswer(${enigma.id})">
                                ‚úÖ Valider
                            </button>
                            <p style="font-size: 0.85em; color: #666; margin-top: 5px;">
                                Tentatives restantes : ${3 - (progress?.wrong_attempts || 0)}
                            </p>
                        </div>
                    `;
                            }
                        }

                        enigmeDiv.innerHTML = content;
                        container.appendChild(enigmeDiv);
                    }

                } catch (error) {
                    console.error('Error loading enigmas:', error);
                    container.innerHTML = '<p style="color: #ff4444;">Erreur lors du chargement des √©nigmes.</p>';
                }
            },

            async getProgress(enigmaId) {
                try {
                    let query = supabase
                        .from('enigma_progress')
                        .select('*')
                        .eq('enigma_id', enigmaId);

                    if (this.currentUser.team_id) {
                        query = query.eq('team_id', this.currentUser.team_id);
                    } else {
                        query = query.eq('player_id', this.currentUser.id);
                    }

                    const { data: existing } = await query.maybeSingle();

                    if (existing) {
                        return existing;
                    }

                    // Create new progress
                    const { data: newProgress } = await supabase
                        .from('enigma_progress')
                        .insert([{
                            player_id: this.currentUser.team_id ? null : this.currentUser.id,
                            team_id: this.currentUser.team_id || null,
                            enigma_id: enigmaId,
                            wrong_attempts: 0,
                            hints_used: [],
                            lockout_count: 0,
                            qr_scanned: false,
                            solved: false,
                            points_earned: 0
                        }])
                        .select()
                        .single();

                    return newProgress;
                } catch (error) {
                    console.error('Error getting progress:', error);
                    return null;
                }
            },

            isLocked(progress) {
                if (!progress || !progress.locked_until) return { locked: false };

                const now = new Date();
                const lockEnd = new Date(progress.locked_until);

                if (now < lockEnd) {
                    const remaining = Math.ceil((lockEnd - now) / 1000 / 60);
                    return {
                        locked: true,
                        remaining: remaining
                    };
                }

                return { locked: false };
            },

            async updateProgress(progressId, updates) {
                const { error } = await supabase
                    .from('enigma_progress')
                    .update({
                        ...updates,
                        updated_at: new Date().toISOString()
                    })
                    .eq('id', progressId);

                if (error) throw error;
            },

            async requestHint(enigmaId, hintNumber) {
                try {
                    const progress = await this.getProgress(enigmaId);

                    // Check if hint already used
                    if (progress.hints_used?.includes(hintNumber)) {
                        showToast('Tu as d√©j√† utilis√© cet indice !', 'warning');
                        return;
                    }

                    // Check if previous hint was used
                    if (hintNumber > 1 && !progress.hints_used?.includes(hintNumber - 1)) {
                        showToast('Tu dois utiliser les indices dans l\'ordre !', 'warning');
                        return;
                    }

                    // Determine cost based on hint number
                    let cost = 5;
                    if (hintNumber === 2) cost = 15;
                    if (hintNumber === 3) cost = 30;

                    // Update hints used
                    const newHints = progress.hints_used ? [...progress.hints_used, hintNumber] : [hintNumber];
                    await this.updateProgress(progress.id, { hints_used: newHints });

                    // Deduct points (can go negative)
                    const newPoints = this.currentUser.points - cost;
                    await supabase
                        .from('players')
                        .update({ points: newPoints })
                        .eq('id', this.currentUser.id);

                    if (this.currentUser.team_id) {
                        const { data: team } = await supabase
                            .from('teams')
                            .select('points')
                            .eq('id', this.currentUser.team_id)
                            .maybeSingle();

                        if (team) {
                            await supabase
                                .from('teams')
                                .update({ points: team.points - cost })
                                .eq('id', this.currentUser.team_id);
                        }
                    }

                    showToast(`‚úÖ Indice d√©bloqu√© ! (-${cost} points)`, 'success');

                    // Reload
                    await this.loadUserData();
                    await this.loadEnigmes();

                } catch (error) {
                    console.error('Error:', error);
                    showToast('‚ùå Erreur lors de la demande d\'indice', 'error');
                }
            },

            async submitAnswer(enigmaId) {
                const answer = document.getElementById(`answer-${enigmaId}`).value.trim();

                if (!answer) {
                    showToast('‚ùå Entre une r√©ponse !', 'error');
                    return;
                }

                try {
                    const progress = await this.getProgress(enigmaId);

                    // Check if locked
                    const lockStatus = this.isLocked(progress);
                    if (lockStatus.locked) {
                        showToast(`üîí Tu es bloqu√© encore ${lockStatus.remaining} minutes`, 'error');
                        return;
                    }

                    // Get enigma info (WITHOUT answer and qr_secret)
                    const { data: enigma } = await supabase
                        .from('enigmas')
                        .select('id, number, title, validation_type')
                        .eq('id', enigmaId)
                        .single();

                    // Use RPC to validate answer securely (answer never leaves server)
                    const { data: validationResult, error: rpcError } = await supabase
                        .rpc('validate_enigma_answer', {
                            p_enigma_id: enigmaId,
                            p_answer: answer.toLowerCase().trim()
                        });

                    if (rpcError) throw rpcError;
                    const isCorrect = validationResult;

                    if (enigma.validation_type === 'manual') {
                        // Check if already submitted
                        let submissionQuery = supabase
                            .from('submissions')
                            .select('id')
                            .eq('enigma_id', enigmaId)
                            .eq('status', 'pending');

                        if (this.currentUser.team_id) {
                            submissionQuery = submissionQuery.eq('team_id', this.currentUser.team_id);
                        } else {
                            submissionQuery = submissionQuery.eq('player_id', this.currentUser.id);
                        }

                        const { data: existingSubmission } = await submissionQuery.maybeSingle();

                        if (existingSubmission) {
                            showToast('‚è≥ Tu as d√©j√† une r√©ponse en attente de validation !', 'warning');
                            return;
                        }

                        // Make sure progress exists before submission
                        if (!progress) {
                            showToast('‚ùå Erreur : progression non trouv√©e', 'error');
                            return;
                        }

                        // Create submission for manual validation
                        const { error } = await supabase
                            .from('submissions')
                            .insert([{
                                enigma_id: enigmaId,
                                player_id: this.currentUser.id,
                                team_id: this.currentUser.team_id || null,
                                answer: answer,
                                status: 'pending'
                            }]);

                        if (error) throw error;

                        showToast('‚úÖ R√©ponse soumise ! En attente de validation par HDN...', 'info');
                        await this.loadEnigmes();

                    } else {
                        // Auto validation
                        if (isCorrect) {
                            // Mark as solved but DON'T calculate or award points yet
                            await this.updateProgress(progress.id, {
                                solved: true,
                                solved_at: new Date().toISOString(),
                                points_earned: 0 // Will be calculated at QR scan
                            });

                            showToast(`üéâ Bonne r√©ponse ! Va scanner le QR code pour gagner tes points !`, 'success');
                            await this.loadEnigmes();
                            await this.loadUserData();

                        } else {
                            // Wrong answer
                            const newAttempts = progress.wrong_attempts + 1;

                            if (newAttempts >= 3) {
                                // Lock for 30 minutes
                                const lockUntil = new Date();
                                lockUntil.setMinutes(lockUntil.getMinutes() + 15);

                                await this.updateProgress(progress.id, {
                                    wrong_attempts: newAttempts,
                                    locked_until: lockUntil.toISOString(),
                                    lockout_count: progress.lockout_count + 1
                                });

                                showToast('‚ùå Mauvaise r√©ponse ! √ânigme bloqu√©e pour 15 minutes.', 'error');
                            } else {
                                await this.updateProgress(progress.id, {
                                    wrong_attempts: newAttempts
                                });

                                showToast(`‚ùå Mauvaise r√©ponse ! (${3 - newAttempts} essais restants)`, 'error');
                            }

                            await this.loadEnigmes();
                        }
                    }

                } catch (error) {
                    console.error('Error:', error);
                    showToast('‚ùå Erreur lors de la soumission : ' + error.message, 'error');
                }
            },

            async awardPoints(points) {
                try {
                    // Update player points
                    const newPoints = this.currentUser.points + points;
                    await supabase
                        .from('players')
                        .update({ points: newPoints })
                        .eq('id', this.currentUser.id);

                    // Update team points if applicable
                    if (this.currentUser.team_id) {
                        const { data: team } = await supabase
                            .from('teams')
                            .select('points')
                            .eq('id', this.currentUser.team_id)
                            .maybeSingle();

                        if (team) {
                            await supabase
                                .from('teams')
                                .update({ points: team.points + points })
                                .eq('id', this.currentUser.team_id);
                        }
                    }
                } catch (error) {
                    console.error('Error awarding points:', error);
                }
            },

            // ========== QR SCANNER ==========

            async openQRScanner(enigmaId) {
                try {
                    // Get enigma info WITHOUT qr_secret
                    const { data: enigma } = await supabase
                        .from('enigmas')
                        .select('id, number, title, location')
                        .eq('id', enigmaId)
                        .single();

                    if (!enigma) {
                        showToast('‚ùå √ânigme non trouv√©e', 'error');
                        return;
                    }

                    // Check if QR is configured using RPC
                    const { data: hasQR } = await supabase.rpc('enigma_has_qr', { p_enigma_id: enigmaId });
                    if (!hasQR) {
                        showToast('‚ùå QR Code non configur√© pour cette √©nigme', 'error');
                        return;
                    }

                    // Store enigmaId for the callback
                    this.currentScanEnigmaId = enigmaId;

                    // Create modal
                    const modal = document.createElement('div');
                    modal.id = 'qrScannerModal';
                    modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 10000; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 20px;';
                    modal.innerHTML = `
                        <h2 style="color: #81FE0E; margin-bottom: 20px;">üì± Scan le QR Code</h2>
                        <p style="color: white; margin-bottom: 20px;">√ânigme #${enigma.number} - ${enigma.location}</p>
                        <div id="qrScanner" style="max-width: 500px; width: 100%;"></div>
                        <button class="btn btn-danger" style="margin-top: 20px;" onclick="hdnApp.closeQRScanner()">‚ùå Fermer</button>
                    `;
                    document.body.appendChild(modal);

                    // Initialize scanner
                    this.qrScanner = new Html5Qrcode("qrScanner");

                    const self = this;
                    await this.qrScanner.start(
                        { facingMode: "environment" },
                        {
                            fps: 10,
                            qrbox: { width: 250, height: 250 }
                        },
                        async (decodedText) => {
                            // Stop scanner immediately
                            await self.qrScanner.stop();

                            // Validate QR using RPC (qr_secret never sent to client)
                            const { data: isValidQR, error: rpcError } = await supabase
                                .rpc('validate_qr_code', {
                                    p_enigma_id: self.currentScanEnigmaId,
                                    p_scanned_code: decodedText
                                });

                            if (rpcError) {
                                console.error('RPC Error:', rpcError);
                                showToast('‚ùå Erreur de validation', 'error');
                                return;
                            }

                            if (isValidQR) {
                                // Get progress to calculate points NOW
                                const progress = await self.getProgress(self.currentScanEnigmaId);

                                // Calculate points based on how many QR codes have been scanned for this enigma
                                let countQuery = supabase
                                    .from('enigma_progress')
                                    .select('id', { count: 'exact' })
                                    .eq('enigma_id', self.currentScanEnigmaId)
                                    .eq('qr_scanned', true);

                                const { count } = await countQuery;

                                let points = 50;
                                if (count === 0) points = 200;
                                else if (count === 1) points = 150;
                                else if (count === 2) points = 100;

                                // Mark as scanned and store points
                                await self.updateProgress(progress.id, {
                                    qr_scanned: true,
                                    points_earned: points
                                });

                                // NOW award the points!
                                await self.awardPoints(points);

                                self.closeQRScanner();
                                showToast(`‚úÖ QR Code valid√© !\n\n+${points} points gagn√©s !`, 'success');
                                await self.loadEnigmes();
                                await self.loadUserData();
                            } else {
                                // Wrong QR - show message and restart scanner
                                showToast(`‚ùå Mauvais QR code !\n\nTu dois scanner le QR de l'√©nigme #${enigma.number}\nEmplacement : ${enigma.location}`, 'error');

                                // Restart scanner after 2 seconds
                                setTimeout(async () => {
                                    try {
                                        await self.qrScanner.start(
                                            { facingMode: "environment" },
                                            {
                                                fps: 10,
                                                qrbox: { width: 250, height: 250 }
                                            },
                                            arguments.callee
                                        );
                                    } catch (err) {
                                        console.error('Error restarting scanner:', err);
                                    }
                                }, 2000);
                            }
                        }
                    );

                } catch (error) {
                    console.error('Error opening QR scanner:', error);
                    showToast('‚ùå Erreur lors de l\'ouverture du scanner', 'error');
                }
            },

            async closeQRScanner() {
                if (this.qrScanner) {
                    try {
                        await this.qrScanner.stop();
                    } catch (err) {
                        console.log('Scanner already stopped');
                    }
                    this.qrScanner = null;
                }
                const modal = document.getElementById('qrScannerModal');
                if (modal) {
                    modal.remove();
                }
            },

            // ========== CLASSEMENT ==========

            async loadClassement() {
                const container = document.getElementById('rankingList');
                container.innerHTML = '<div class="loading">Chargement du classement...</div>';

                try {
                    // Get solo players (exclude test accounts) - WITHOUT password
                    const { data: soloPlayers } = await supabase
                        .from('players')
                        .select('id, pseudo, points, team_id, is_test')
                        .is('team_id', null)
                        .eq('is_test', false);

                    // Get teams
                    const { data: teams } = await supabase
                        .from('teams')
                        .select('id, name, points');

                    // Create unified ranking array
                    let ranking = [];

                    // Add solo players
                    if (soloPlayers) {
                        soloPlayers.forEach(player => {
                            ranking.push({
                                type: 'solo',
                                name: player.pseudo,
                                points: player.points || 0,
                                members: null
                            });
                        });
                    }

                    // Add teams
                    if (teams) {
                        for (const team of teams) {
                            // Get team members
                            const { data: members } = await supabase
                                .from('players')
                                .select('pseudo')
                                .eq('team_id', team.id);

                            ranking.push({
                                type: 'team',
                                name: team.name,
                                points: team.points || 0,
                                members: members ? members.map(m => m.pseudo).join(', ') : ''
                            });
                        }
                    }

                    // Sort by points (descending)
                    ranking.sort((a, b) => b.points - a.points);

                    // Display unified ranking
                    container.innerHTML = '';

                    if (ranking.length === 0) {
                        container.innerHTML = '<p style="text-align: center; color: #666;">Aucun joueur dans le classement.</p>';
                        return;
                    }

                    const header = document.createElement('h3');
                    header.textContent = 'üèÜ Classement G√©n√©ral';
                    container.appendChild(header);

                    ranking.forEach((entry, index) => {
                        const rankDiv = document.createElement('div');
                        rankDiv.className = 'ranking-item';

                        let posClass = '';
                        if (index === 0) posClass = 'first';
                        else if (index === 1) posClass = 'second';
                        else if (index === 2) posClass = 'third';

                        const typeLabel = entry.type === 'solo' ? 'üë§ Solo' : 'üë• √âquipe';
                        const membersHtml = entry.members
                            ? `<p style="font-size: 0.85em; color: #666; margin-top: 5px;">${entry.members}</p>`
                            : '';

                        rankDiv.innerHTML = `
                <div class="ranking-position ${posClass}">#${index + 1}</div>
                <div class="ranking-info">
                    <strong>${entry.name}</strong>
                    <span style="font-size: 0.9em; color: #81FE0E; margin-left: 10px;">${typeLabel}</span>
                    ${membersHtml}
                </div>
                <div class="ranking-points">${entry.points} pts</div>
            `;
                        container.appendChild(rankDiv);
                    });

                } catch (error) {
                    console.error('Error loading ranking:', error);
                    container.innerHTML = '<p style="color: #ff4444;">Erreur lors du chargement du classement.</p>';
                }
            },

            // ========== ADMIN PANEL ==========

            async loadAdminPanel() {
                if (!this.currentUser.is_admin) {
                    showToast('‚ùå Acc√®s refus√©', 'error');
                    return;
                }

                // Load stats
                const { data: players } = await supabase.from('players').select('id', { count: 'exact' });
                const { data: enigmas } = await supabase.from('enigmas').select('id', { count: 'exact' });
                const { data: pending } = await supabase
                    .from('submissions')
                    .select('id', { count: 'exact' })
                    .eq('status', 'pending');

                document.getElementById('adminTotalPlayers').textContent = players?.length || 0;
                document.getElementById('adminTotalEnigmas').textContent = enigmas?.length || 0;
                document.getElementById('adminPendingValidations').textContent = pending?.length || 0;

                // Load enigmas list
                await this.loadAdminEnigmas();

                // Load pending validations
                await this.loadPendingValidations();
            },

            async loadAdminEnigmas() {
                const container = document.getElementById('adminEnigmasList');

                try {
                    const { data: enigmas } = await supabase
                        .from('enigmas')
                        .select('*')
                        .order('number', { ascending: true });

                    if (!enigmas || enigmas.length === 0) {
                        container.innerHTML = '<p style="color: #666;">Aucune √©nigme cr√©√©e.</p>';
                        return;
                    }

                    container.innerHTML = '';

                    enigmas.forEach(enigma => {
                        const div = document.createElement('div');
                        div.style.cssText = 'background: #f9f9f9; padding: 15px; margin: 10px 0; border-radius: 8px; border-left: 4px solid #343973;';

                        div.innerHTML = `
                            <h4 style="color: #343973; margin-bottom: 10px;">
                                √ânigme #${enigma.number} - ${enigma.title}
                                ${enigma.published ? '<span class="badge badge-success">Publi√©e</span>' : '<span class="badge badge-warning">Brouillon</span>'}
                                ${enigma.scheduled_at ? `<span class="badge badge-primary">Programm√©e: ${formatParisDateTime(enigma.scheduled_at)}</span>` : ''}
                            </h4>
                            <p style="color: #666; margin: 5px 0;">R√©ponse: ${enigma.answer}</p>
                            <p style="color: #666; margin: 5px 0;">Lieu QR: ${enigma.location}</p>
                            <p style="color: #666; margin: 5px 0;">Code QR: <strong>${enigma.qr_secret}</strong></p>
                            ${enigma.image_url ? `<p style="color: #666; margin: 5px 0;">üì∑ Image: <a href="${enigma.image_url}" target="_blank" style="color: #343973;">Voir</a></p>` : ''}
                            <div style="margin-top: 10px;">
                                <button class="btn btn-primary" onclick="hdnApp.generateAndShowQR('${enigma.qr_secret}', ${enigma.number})">üì• T√©l√©charger QR</button>
                                <button class="btn btn-primary" onclick="hdnApp.editEnigma(${enigma.id})">‚úèÔ∏è Modifier</button>
                                <button class="btn ${enigma.published ? 'btn-warning' : 'btn-success'}" 
                                        onclick="hdnApp.togglePublish(${enigma.id}, ${!enigma.published})">
                                    ${enigma.published ? 'üì• D√©publier' : 'üì§ Publier'}
                                </button>
                                <button class="btn btn-danger" onclick="hdnApp.deleteEnigma(${enigma.id})">üóëÔ∏è Supprimer</button>
                            </div>
                            <div id="qr-display-${enigma.number}" class="qr-code-container hidden"></div>
                        `;

                        container.appendChild(div);
                    });

                } catch (error) {
                    console.error('Error loading admin enigmas:', error);
                    container.innerHTML = '<p style="color: #ff4444;">Erreur lors du chargement.</p>';
                }
            },

            // ========== QR CODE GENERATION ==========

            generateAndShowQR(qrSecret, enigmaNumber) {
                const container = document.getElementById(`qr-display-${enigmaNumber}`);

                // Toggle visibility
                if (!container.classList.contains('hidden')) {
                    container.classList.add('hidden');
                    container.innerHTML = '';
                    return;
                }

                container.classList.remove('hidden');
                container.innerHTML = `
                    <h4 style="color: #343973; margin-bottom: 10px;">QR Code pour √ânigme #${enigmaNumber}</h4>
                    <p style="color: #666; margin-bottom: 10px;">Code: <strong>${qrSecret}</strong></p>
                    <div id="qrcode-${enigmaNumber}"></div>
                    <button class="btn btn-success" style="margin-top: 10px;" onclick="hdnApp.downloadQR(${enigmaNumber})">
                        üíæ T√©l√©charger l'image
                    </button>
                `;

                // Generate QR Code
                new QRCode(document.getElementById(`qrcode-${enigmaNumber}`), {
                    text: qrSecret,
                    width: 256,
                    height: 256,
                    colorDark: "#000000",
                    colorLight: "#ffffff",
                    correctLevel: QRCode.CorrectLevel.H
                });
            },

            downloadQR(enigmaNumber) {
                const canvas = document.querySelector(`#qrcode-${enigmaNumber} canvas`);
                if (!canvas) {
                    showToast('‚ùå QR Code non trouv√©', 'error');
                    return;
                }

                // Convert to blob and download
                canvas.toBlob(blob => {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `HDN-QRCode-Enigme-${enigmaNumber}.png`;
                    a.click();
                    URL.revokeObjectURL(url);
                    showToast('‚úÖ QR Code t√©l√©charg√© !', 'success');
                });
            },

            async togglePublish(enigmaId, shouldPublish) {
                try {
                    const { error } = await supabase
                        .from('enigmas')
                        .update({ published: shouldPublish })
                        .eq('id', enigmaId);

                    if (error) throw error;

                    showToast(shouldPublish ? '‚úÖ √ânigme publi√©e !' : '‚úÖ √ânigme d√©publi√©e !', 'success');
                    await this.loadAdminEnigmas();

                } catch (error) {
                    console.error('Error:', error);
                    showToast('‚ùå Erreur lors de la modification', 'error');
                }
            },

            async deleteEnigma(enigmaId) {
                if (!confirm('Es-tu s√ªr de vouloir supprimer cette √©nigme ?')) return;

                try {
                    const { error } = await supabase
                        .from('enigmas')
                        .delete()
                        .eq('id', enigmaId);

                    if (error) throw error;

                    showToast('‚úÖ √ânigme supprim√©e !', 'success');

                    // Renumber remaining enigmas
                    const { data: remaining } = await supabase
                        .from('enigmas')
                        .select('*')
                        .order('number', { ascending: true });

                    for (let i = 0; i < remaining.length; i++) {
                        await supabase
                            .from('enigmas')
                            .update({ number: i + 1 })
                            .eq('id', remaining[i].id);
                    }

                    await this.loadAdminEnigmas();

                } catch (error) {
                    console.error('Error:', error);
                    showToast('‚ùå Erreur lors de la suppression', 'error');
                }
            },

            async editEnigma(enigmaId) {
                try {
                    const { data: enigma } = await supabase
                        .from('enigmas')
                        .select('*')
                        .eq('id', enigmaId)
                        .single();

                    if (!enigma) return;

                    // Fill form with current data
                    document.getElementById('enigmaTitle').value = enigma.title;
                    document.getElementById('enigmaDescription').value = enigma.description;
                    document.getElementById('enigmaImageUrl').value = enigma.image_url || '';
                    document.getElementById('enigmaAnswer').value = enigma.answer;
                    document.getElementById('enigmaLocation').value = enigma.location;
                    document.getElementById('enigmaValidation').value = enigma.validation_type;
                    document.getElementById('enigmaHint1').value = enigma.hint1 || '';
                    document.getElementById('enigmaHint2').value = enigma.hint2 || '';
                    document.getElementById('enigmaHint3').value = enigma.hint3 || '';
                    document.getElementById('enigmaPublished').checked = enigma.published;

                    if (enigma.scheduled_at) {
                        // Convert to Paris time for the datetime-local input
                        const parisDate = toParisTime(enigma.scheduled_at);
                        const year = parisDate.getFullYear();
                        const month = String(parisDate.getMonth() + 1).padStart(2, '0');
                        const day = String(parisDate.getDate()).padStart(2, '0');
                        const hours = String(parisDate.getHours()).padStart(2, '0');
                        const minutes = String(parisDate.getMinutes()).padStart(2, '0');
                        document.getElementById('enigmaSchedule').value = `${year}-${month}-${day}T${hours}:${minutes}`;
                    }

                    // Change button to "Update"
                    const btn = document.querySelector('#admin-section .btn-success');
                    btn.textContent = 'üíæ Mettre √† jour';
                    btn.onclick = () => this.updateEnigma(enigmaId);

                    // Scroll to form
                    document.getElementById('enigmaTitle').scrollIntoView({ behavior: 'smooth', block: 'center' });

                } catch (error) {
                    console.error('Error:', error);
                    showToast('‚ùå Erreur lors du chargement', 'error');
                }
            },

            async updateEnigma(enigmaId) {
                const title = document.getElementById('enigmaTitle').value.trim();
                const description = document.getElementById('enigmaDescription').value.trim();
                const imageUrl = document.getElementById('enigmaImageUrl').value.trim();
                const answer = document.getElementById('enigmaAnswer').value.trim();
                const location = document.getElementById('enigmaLocation').value.trim();
                const validationType = document.getElementById('enigmaValidation').value;
                const hint1 = document.getElementById('enigmaHint1').value.trim();
                const hint2 = document.getElementById('enigmaHint2').value.trim();
                const hint3 = document.getElementById('enigmaHint3').value.trim();
                const published = document.getElementById('enigmaPublished').checked;
                const schedule = document.getElementById('enigmaSchedule').value;

                if (!title || !description || !answer || !location) {
                    showToast('‚ùå Remplis tous les champs obligatoires !', 'error');
                    return;
                }

                try {
                    // Get current enigma to preserve QR secret
                    const { data: currentEnigma } = await supabase
                        .from('enigmas')
                        .select('qr_secret')
                        .eq('id', enigmaId)
                        .single();

                    // Generate new QR secret if not exists
                    let qrSecret = currentEnigma?.qr_secret;
                    if (!qrSecret) {
                        qrSecret = 'HDN-E' + enigmaId + '-' + Math.random().toString(36).substr(2, 6).toUpperCase();
                    }

                    const { error } = await supabase
                        .from('enigmas')
                        .update({
                            title: title,
                            description: description,
                            image_url: imageUrl || null,
                            answer: answer,
                            location: location,
                            qr_secret: qrSecret,
                            validation_type: validationType,
                            hint1: hint1 || null,
                            hint2: hint2 || null,
                            hint3: hint3 || null,
                            published: published,
                            scheduled_at: this.convertLocalToUTC(schedule)
                        })
                        .eq('id', enigmaId);

                    if (error) throw error;

                    showToast('‚úÖ √ânigme mise √† jour !', 'success');

                    // Reset form
                    this.resetEnigmaForm();
                    document.getElementById('enigmaSchedule').value = '';

                    // Change button back
                    const btn = document.querySelector('#admin-section .btn-success');
                    btn.textContent = '‚úÖ Cr√©er l\'√©nigme';
                    btn.onclick = () => this.createEnigma();

                    // Reload list
                    await this.loadAdminEnigmas();

                } catch (error) {
                    console.error('Error:', error);
                    showToast('‚ùå Erreur lors de la mise √† jour : ' + error.message, 'error');
                }
            },

            async createEnigma() {
                const title = document.getElementById('enigmaTitle').value.trim();
                const description = document.getElementById('enigmaDescription').value.trim();
                const imageUrl = document.getElementById('enigmaImageUrl').value.trim();
                const answer = document.getElementById('enigmaAnswer').value.trim();
                const location = document.getElementById('enigmaLocation').value.trim();
                const validationType = document.getElementById('enigmaValidation').value;
                const hint1 = document.getElementById('enigmaHint1').value.trim();
                const hint2 = document.getElementById('enigmaHint2').value.trim();
                const hint3 = document.getElementById('enigmaHint3').value.trim();
                const published = document.getElementById('enigmaPublished').checked;
                const schedule = document.getElementById('enigmaSchedule').value;

                if (!title || !description || !answer || !location) {
                    showToast('‚ùå Remplis tous les champs obligatoires !', 'error');
                    return;
                }

                try {
                    // Get next number (max + 1)
                    const { data: existingEnigmas } = await supabase
                        .from('enigmas')
                        .select('number')
                        .order('number', { ascending: false })
                        .limit(1);

                    const nextNumber = existingEnigmas && existingEnigmas.length > 0
                        ? existingEnigmas[0].number + 1
                        : 1;

                    // Generate QR secret automatically
                    const qrSecret = 'HDN-E' + nextNumber + '-' + Math.random().toString(36).substr(2, 6).toUpperCase();

                    const { error } = await supabase
                        .from('enigmas')
                        .insert([{
                            number: nextNumber,
                            title: title,
                            description: description,
                            image_url: imageUrl || null,
                            answer: answer,
                            location: location,
                            validation_type: validationType,
                            hint1: hint1 || null,
                            hint2: hint2 || null,
                            hint3: hint3 || null,
                            qr_secret: qrSecret,
                            published: published,
                            scheduled_at: this.convertLocalToUTC(schedule)
                        }]);

                    if (error) throw error;

                    showToast(`‚úÖ √ânigme #${nextNumber} cr√©√©e !\n\nCode QR: ${qrSecret}`, 'success');

                    // Reset form
                    this.resetEnigmaForm();
                    document.getElementById('enigmaSchedule').value = '';

                    // Reload list
                    await this.loadAdminEnigmas();

                } catch (error) {
                    console.error('Error:', error);
                    showToast('‚ùå Erreur lors de la cr√©ation : ' + error.message, 'error');
                }
            },

            resetEnigmaForm() {
                document.getElementById('enigmaTitle').value = '';
                document.getElementById('enigmaDescription').value = '';
                document.getElementById('enigmaImageUrl').value = '';
                document.getElementById('enigmaAnswer').value = '';
                document.getElementById('enigmaLocation').value = '';
                document.getElementById('enigmaValidation').value = 'auto';
                document.getElementById('enigmaHint1').value = '';
                document.getElementById('enigmaHint2').value = '';
                document.getElementById('enigmaHint3').value = '';
                document.getElementById('enigmaPublished').checked = false;
            },

            async loadPendingValidations() {
                const container = document.getElementById('pendingValidationsList');

                try {
                    const { data: submissions } = await supabase
                        .from('submissions')
                        .select(`
                            *,
                            enigmas (title, number, answer),
                            players (pseudo)
                        `)
                        .eq('status', 'pending')
                        .order('created_at', { ascending: true });

                    if (!submissions || submissions.length === 0) {
                        container.innerHTML = '<p style="color: #666;">Aucune validation en attente.</p>';
                        return;
                    }

                    container.innerHTML = '';

                    submissions.forEach(sub => {
                        const div = document.createElement('div');
                        div.style.cssText = 'background: #f9f9f9; padding: 15px; margin: 10px 0; border-radius: 8px; border-left: 4px solid #ffaa00;';

                        const pseudo = sub.players?.pseudo || '√âquipe';
                        const enigmaTitle = sub.enigmas?.title || '√ânigme inconnue';
                        const correctAnswer = sub.enigmas?.answer || '';

                        div.innerHTML = `
                            <h4 style="color: #343973; margin-bottom: 10px;">
                                ${pseudo} - √ânigme #${sub.enigmas?.number} : ${enigmaTitle}
                            </h4>
                            <p style="color: #666; margin: 5px 0;"><strong>R√©ponse propos√©e :</strong> ${sub.answer}</p>
                            <p style="color: #666; margin: 5px 0;"><strong>R√©ponse correcte :</strong> ${correctAnswer}</p>
                            <div style="margin-top: 10px;">
                                <button class="btn btn-success" onclick="hdnApp.validateSubmission(${sub.id}, true)">‚úÖ Accepter</button>
                                <button class="btn btn-danger" onclick="hdnApp.validateSubmission(${sub.id}, false)">‚ùå Refuser</button>
                            </div>
                        `;

                        container.appendChild(div);
                    });

                } catch (error) {
                    console.error('Error loading pending validations:', error);
                    container.innerHTML = '<p style="color: #ff4444;">Erreur lors du chargement.</p>';
                }
            },

            async validateSubmission(submissionId, accepted) {
                try {
                    // Get submission details
                    const { data: submission } = await supabase
                        .from('submissions')
                        .select('*')
                        .eq('id', submissionId)
                        .single();

                    if (!submission) return;

                    // Update submission status
                    await supabase
                        .from('submissions')
                        .update({ status: accepted ? 'accepted' : 'rejected' })
                        .eq('id', submissionId);

                    if (accepted) {
                        // Get progress
                        let query = supabase
                            .from('enigma_progress')
                            .select('*')
                            .eq('enigma_id', submission.enigma_id);

                        if (submission.team_id) {
                            query = query.eq('team_id', submission.team_id);
                        } else {
                            query = query.eq('player_id', submission.player_id);
                        }

                        const { data: progress } = await query.maybeSingle();

                        if (progress) {
                            // Mark as solved but DON'T calculate points yet (will be done at QR scan)
                            await supabase
                                .from('enigma_progress')
                                .update({
                                    solved: true,
                                    solved_at: new Date().toISOString(),
                                    points_earned: 0
                                })
                                .eq('id', progress.id);
                        }
                    }

                    showToast(accepted ? '‚úÖ R√©ponse accept√©e !' : '‚ùå R√©ponse refus√©e !', accepted ? 'success' : 'error');
                    await this.loadPendingValidations();
                    await this.loadAdminPanel();

                } catch (error) {
                    console.error('Error:', error);
                    showToast('‚ùå Erreur lors de la validation', 'error');
                }
            },

            async exportData() {
                // Admin check
                if (!this.currentUser?.is_admin) {
                    showToast('‚ùå Acc√®s refus√© - Admin uniquement', 'error');
                    return;
                }

                try {
                    // Export without passwords
                    const { data: players } = await supabase
                        .from('players')
                        .select('id, pseudo, type, points, team_id, is_admin, is_test, created_at');
                    const { data: teams } = await supabase
                        .from('teams')
                        .select('id, name, code, points, leader, created_at');
                    const { data: enigmas } = await supabase
                        .from('enigmas')
                        .select('id, number, title, description, answer, location, qr_secret, validation_type, hint1, hint2, hint3, published, scheduled_at');
                    const { data: progress } = await supabase
                        .from('enigma_progress')
                        .select('*');
                    const { data: submissions } = await supabase
                        .from('submissions')
                        .select('*');

                    const exportData = {
                        exported_at: new Date().toISOString(),
                        players,
                        teams,
                        enigmas,
                        progress,
                        submissions
                    };

                    const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `hdn-export-${new Date().toISOString().split('T')[0]}.json`;
                    a.click();

                    showToast('‚úÖ Donn√©es export√©es !', 'success');

                } catch (error) {
                    console.error('Error:', error);
                    showToast('‚ùå Erreur lors de l\'export', 'error');
                }
            }
        };

        // Initialize app when page loads
        document.addEventListener('DOMContentLoaded', () => {
            hdnApp.init();
        });
    </script>
</body>

</html>