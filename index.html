<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HDN Christmas Project 2025</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">

    <!-- Supabase JS Client -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <!-- QR Code Scanner -->
    <script src="https://unpkg.com/html5-qrcode@2.3.8/html5-qrcode.min.js"></script>
    <!-- QRCode.js for generation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Orbitron', sans-serif;
            background-color: #000000;
            color: #ffffff;
            min-height: 100vh;
            width: 100%;
            display: block;
        }

        p {
            font-size: clamp(0.875rem, 0.125vw + 0.85rem, 1rem);
        }

        .container {
            max-width: 1281px;
  margin: 0 auto;
  padding: 10px;
  display: flex;
  flex-flow: column nowrap;
  justify-content: center;
  align-items: center;
        }

        /* Header */
        header {
            background: linear-gradient(135deg, #343973, #4a5193);
            padding: 30px 20px;
            margin-bottom: 30px;
        }

        header h1 {
            text-align: center;
            font-size: clamp(1.125rem, 0.75vw + 0.975rem, 1.875rem);
            color: #81FE0E;
            text-transform: uppercase;
            letter-spacing: 5px;
            margin-bottom: 10px;
        }

        header p {
            text-align: center;
            color: #ffffff;
            font-size: 16px;
            opacity: 0.9;
        }

        /* Cards */
        .card {
            background: white;
            color: #000000;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            max-width: 1000px;
            margin-left: auto;
            margin-right: auto;
            width: 100%;
        }

        .card h2 {
            color: #343973;
            margin-bottom: 20px;
            font-size: 1.8em;
            border-bottom: 3px solid #81FE0E;
            padding-bottom: 10px;
        }

        .card h3 {
            color: #343973;
            margin: 20px 0 15px 0;
            font-size: 1.3em;
        }

        /* Navigation */
        nav {
            background: white;
  border-radius: 15px;
  padding: 20px;
  margin-bottom: 30px;
  box-shadow: 0 0 30px rgba(129, 254, 14, 0.2);
  display: flex;
  gap: 10px;
  flex-wrap: wrap;
  justify-content: center;
  width: 100%;
  max-width: 1000px;
        }

        nav button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.9em;
            background: #343973;
            color: white;
        }

        nav button:hover {
            background: #4a5193;
            transform: translateY(-2px);
        }

        nav button.active {
            background: #81FE0E;
            color: #000000;
        }

        /* Buttons */
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s;
            margin: 5px;
            font-size: 0.9em;
        }

        .btn-primary {
            background: #343973;
            color: white;
        }

        .btn-primary:hover {
            background: #4a5193;
            transform: translateY(-2px);
        }

        .btn-success {
            background: #81FE0E;
            color: #000000;
        }

        .btn-success:hover {
            background: #6dd90c;
            transform: translateY(-2px);
        }

        .btn-danger {
            background: #ff4444;
            color: white;
        }

        .btn-danger:hover {
            background: #cc0000;
            transform: translateY(-2px);
        }

        .btn-warning {
            background: #ffaa00;
            color: #000000;
        }

        .btn-warning:hover {
            background: #ff8800;
            transform: translateY(-2px);
        }

        /* Forms */
        input, select, textarea {
            width: 100%;
            padding: 12px;
            margin: 10px 0;
            border: 2px solid #343973;
            border-radius: 8px;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.9em;
        }

        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: #81FE0E;
            box-shadow: 0 0 10px rgba(129, 254, 14, 0.3);
        }

        label {
            display: block;
            margin-top: 15px;
            margin-bottom: 5px;
            color: #343973;
            font-weight: 700;
        }

        /* Radio buttons */
        .radio-group {
            display: flex;
            gap: 20px;
            margin: 15px 0;
        }

        .radio-option {
            flex: 1;
            padding: 15px;
            border: 2px solid #343973;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
            background: white;
        }

        .radio-option:hover {
            border-color: #81FE0E;
            box-shadow: 0 0 15px rgba(129, 254, 14, 0.2);
        }

        .radio-option.active {
            border-color: #81FE0E;
            background: rgba(129, 254, 14, 0.1);
        }

        .radio-option input[type="radio"] {
            display: none;
        }

        /* Sections */
        .section {
            display: none;
        }

        .section.active {
            display: block;
            width: 100%;
        }

        /* Stats Grid */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-box {
            background: linear-gradient(135deg, #343973, #4a5193);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 0 20px rgba(129, 254, 14, 0.2);
        }

        .stat-box h3 {
            font-size: 2em;
            color: #81FE0E;
            margin-bottom: 5px;
        }

        .stat-box p {
            font-size: 0.9em;
            opacity: 0.9;
        }

        /* Enigmes List */
        .enigme-item {
            background: #f9f9f9;
            padding: 20px;
            margin: 15px 0;
            border-radius: 10px;
        }

        .enigme-item.solved {
            background: rgba(129, 254, 14, .12);
        }

        .enigme-item.locked {
            border-left-color: #ff4444;
            background: rgba(255, 68, 68, .12);
            opacity: 0.7;
        }

        .enigme-item h3 {
            color: #343973;
            margin-bottom: 10px;
        }

        /* Enigme Image */
        .enigme-image {
            width: 100%;
            max-width: 400px;
            height: auto;
            border-radius: 10px;
            margin: 15px auto;
            display: block;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        /* Badge */
        .badge {
            display: inline-block;
            padding: 5px 12px;
            border-radius: 5px;
            font-size: 0.8em;
            font-weight: 700;
            margin: 2px;
        }

        .badge-success {
            background: #81FE0E;
            color: #000000;
        }

        .badge-primary {
            background: #343973;
            color: white;
        }

        .badge-danger {
            background: #ff4444;
            color: white;
        }

        .badge-warning {
            background: #ffaa00;
            color: #000000;
        }

        /* Classement */
        .ranking-item {
            background: white;
            padding: 15px 20px;
            margin: 10px 0;
            border-radius: 10px;
            display: flex;
            align-items: center;
            gap: 15px;
            box-shadow: 0 0 15px rgba(129, 254, 14, 0.1);
        }

        .ranking-position {
            font-size: 2em;
            font-weight: 900;
            color: #343973;
            min-width: 50px;
            text-align: center;
        }

        .ranking-position.first { color: #FFD700; }
        .ranking-position.second { color: #C0C0C0; }
        .ranking-position.third { color: #CD7F32; }

        .ranking-info {
            flex: 1;
        }

        .ranking-points {
            font-size: 1.5em;
            font-weight: 700;
            color: #000;
        }

        /* Alert */
        .alert {
            padding: 15px 20px;
            border-radius: 8px;
            margin: 15px 0;
            font-weight: 700;
        }

        .alert-success {
            background: #81FE0E;
            color: #000000;
        }

        .alert-danger {
            background: #ff4444;
            color: white;
        }

        .alert-warning {
            background: #ffaa00;
            color: #000000;
        }

        .alert-info {
            background: #343973;
            color: white;
        }

        /* Timer */
        .timer {
            background: linear-gradient(135deg, #343973, #4a5193);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            margin: 20px 0;
            box-shadow: 0 0 20px rgba(129, 254, 14, 0.2);
        }

        .timer h2 {
            color: #81FE0E !important;
            font-size: 2.5em;
            margin: 0;
            border: none;
        }

        .timer p {
            font-size: 1.1em;
            margin-top: 10px;
            opacity: 0.9;
        }

        /* Loading */
        .loading {
            text-align: center;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Responsive */
        @media (max-width: 768px) {
            header h1 {
                font-size: 1.8em;
                letter-spacing: 2px;
            }

            .card {
                padding: 20px;
            }

            .stats-grid {
                grid-template-columns: 1fr;
            }

            .radio-group {
                flex-direction: column;
            }

            nav {
                flex-direction: column;
            }

            nav button {
                width: 100%;
            }

            /* Masquer les boutons du jeu sur mobile */
            .game-buttons-desktop {
                display: none !important;
            }
            
            .game-desktop-warning {
                display: none !important;
            }
            
            .game-mobile-warning {
                display: block !important;
            }
        }

        /* Hide/Show utilities */
        .hidden {
            display: none !important;
        }

        /* User info header */
        .user-info {
            background: white;
  padding: 15px 20px;
  border-radius: 10px;
  margin-bottom: 20px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  box-shadow: 0 0 20px rgba(129, 254, 14, 0.2);
  gap: 15px;
  width: 100%;
        }

        .user-info-left {
            color: #666;
            flex: 1;
        }

        .user-info-left strong {
            color: #000000;
            font-size: 1.3em;
            font-weight: 900;
        }
        
        .user-info-left span {
            color: #343973;
            font-size: 0.9em;
            margin-left: 10px;
        }

        /* Hints section */
        .hints-section {
            display: flex;
            flex-flow: column nowrap;
            justify-content: center;
            align-items: center;
            gap: 10px;
            background: #f0f0f0;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            border-left: 4px solid #343973;
        }

.hints-section div {
    display: flex;
    flex: column nowrap;
    gap: 10px;
}

@media screen and (min-width: 961px) {
    .hints-section div {
    flex: row nowrap;;
}
}

        .hint-item {
            padding: 10px;
            margin: 10px 0;
            background: white;
            border-radius: 8px;
        }

         .hint-item.locked {
            cursor: none;
            opacity: 0.5;
         }


        /* Lockout timer */
        .lockout-timer {
            background: linear-gradient(135deg, #ff4444, #cc0000);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            margin: 15px 0;
            font-weight: 700;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }

        .lockout-timer h3 {
            color: white !important;
            margin: 10px 0 !important;
            font-size: 2em;
        }

        /* QR Scanner */
        #qrScanner {
            margin: 20px auto;
            border: 3px solid #81FE0E;
            border-radius: 10px;
            overflow: hidden;
        }

        /* Toast Notification */
        .toast {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            color: #000;
            padding: 15px 25px;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(129, 254, 14, 0.5);
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            z-index: 9999;
            animation: slideUp 0.3s ease-out;
            max-width: 90%;
            width: fit-content;
            word-wrap: break-word;
            white-space: pre-line;
        }

        .toast.success {
            background: #81FE0E;
            color: #000;
        }

        .toast.error {
            background: #ff4444;
            color: white;
        }

        .toast.warning {
            background: #ffaa00;
            color: #000;
        }

        .toast.info {
            background: #343973;
            color: white;
        }

        @keyframes slideUp {
            from {
                bottom: -100px;
                opacity: 0;
            }
            to {
                bottom: 30px;
                opacity: 1;
            }
        }

        /* Audio player timeline - Spotify style */
        [id^="audio-timeline-"] {
            transition: height 0.15s ease;
        }
        [id^="audio-timeline-"]:hover {
            height: 10px !important;
        }
        [id^="audio-timeline-"]:hover [id^="audio-handle-"] {
            opacity: 1 !important;
        }

        /* Audio player volume bar - Spotify style */
        [id^="audio-volume-bar-"] {
            transition: height 0.15s ease;
        }
        [id^="audio-volume-bar-"]:hover {
            height: 6px !important;
        }
        [id^="audio-volume-bar-"]:hover [id^="audio-volume-handle-"] {
            opacity: 1 !important;
        }

        /* Auth choice buttons */
        .auth-choice-container {
            display: flex;
            flex-flow: column nowrap;
            gap: 20px;
            margin: 30px 0;
        }

        @media screen and (min-width: 961px) {
            .auth-choice-container {
                flex-flow: row nowrap;
            }
        }

        .auth-choice-btn {
            flex: 1;
            padding: 30px 20px;
            border: 3px solid #343973;
            border-radius: 15px;
            background: white;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }

        .auth-choice-btn:hover {
            border-color: #81FE0E;
            transform: translateY(-5px);
            box-shadow: 0 5px 20px rgba(129, 254, 14, 0.3);
        }

        .auth-choice-btn h3 {
            color: #343973;
            margin: 10px 0;
            font-size: 1.5em;
        }

        .auth-choice-btn p {
            color: #666;
            margin: 10px 0 0 0;
        }

        /* QR Code Display */
        .qr-code-container {
            background: #f9f9f9;
            padding: 20px;
            border-radius: 10px;
            margin: 15px 0;
            text-align: center;
            border: 2px solid #343973;
        }

        .qr-code-container canvas,
        .qr-code-container img {
            margin: 15px auto;
            display: block;
            background: white;
            padding: 10px;
            border-radius: 8px;
        }

        /* Floating rules button */
.floating-rules-btn {
    position: fixed;
    bottom: 30px;
    right: 30px;
    background: #343973;
    color: white;
    padding: 15px 25px;
    border-radius: 50px;
    border: none;
    font-family: 'Orbitron', sans-serif;
    font-weight: 700;
    font-size: 1em;
    cursor: pointer;
    transition: all 0.3s;
    z-index: 1000;
}

.floating-rules-btn:hover {
    background: #81FE0E;
    color: #000;
    transform: translateY(-3px);
}

/* Rules modal */
.rules-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.9);
    z-index: 10000;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 20px;
}

.rules-modal-content {
    background: white;
    border-radius: 15px;
    padding: 10px;
    max-width: 800px;
    max-height: 80vh;
    overflow-y: auto;
    position: relative;
}

.rules-modal-close {
    position: absolute;
    top: 15px;
    right: 15px;
    background: #ff4444;
    color: white;
    border: none;
    border-radius: 50%;
    width: 40px;
    height: 40px;
    font-size: 1.5em;
    cursor: pointer;
    font-weight: bold;
}

.rules-modal-close:hover {
    background: #cc0000;
}

/* Password input with eye toggle */
        .password-container {
            position: relative;
            width: 100%;
        }

        .password-container input {
            width: 100%;
            padding-right: 50px;
        }

        .password-toggle {
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1.2em;
            color: #343973;
            padding: 5px;
            opacity: 0.7;
            transition: opacity 0.2s;
        }

        .password-toggle:hover {
            opacity: 1;
        }

        .audio-player {
            flex-flow: column nowrap;
        }

        @media screen and (min-width: 961px) {
            .audio-player {
            flex-flow: row nowrap;
        }
        }
    </style>
</head>

<body>
    <!-- Header -->
    <header>
        <div class="container">
            <h1>üéÑ HDN Saison 3 üéÖ</h1>
            <p>Chasse au Tr√©sor 2025 | 25 Nov - 08 D√©c</p>
        </div>
    </header>

    <!-- Conteneur du jeu (iframe int√©gr√©) -->
    <div id="gameContainer"
         style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: #000; z-index: 2000; opacity: 0; transition: opacity 0.3s ease;">
        <!-- Header du jeu -->
        <div
             style="display: flex; justify-content: space-between; align-items: center; padding: 15px 25px; background: linear-gradient(135deg, #0a0a0a, #1a1a2e); border-bottom: 2px solid #81FE0E;">
            <div style="display: flex; align-items: center; gap: 15px;">
                <span style="font-size: 1.8em;">üéÆ</span>
                <div>
                    <div
                         style="color: #81FE0E; font-weight: bold; font-size: 1.3em; font-family: 'Orbitron', sans-serif;">
                        √âPREUVE FINALE</div>
                    <div style="color: #666; font-size: 0.85em;">HDN Christmas 2025</div>
                </div>
            </div>
            <button onclick="hdnApp.closeGame()"
                    style="background: transparent; color: #ff6b6b; border: 2px solid #ff6b6b; padding: 10px 25px; border-radius: 8px; cursor: pointer; font-weight: bold; font-family: 'Orbitron', sans-serif; transition: all 0.2s;"
                    onmouseover="this.style.background='#ff6b6b';this.style.color='#000'"
                    onmouseout="this.style.background='transparent';this.style.color='#ff6b6b'">
                ‚úï Quitter
            </button>
        </div>
        <!-- Iframe du jeu -->
        <iframe id="gameIframe" src=""
                style="width: 100%; height: calc(100% - 70px); border: none; background: #000;"></iframe>
    </div>

    <div class="container">
        <!-- User Info (hidden by default) -->
        <div class="user-info hidden" id="userInfo">
            <div class="user-info-left">
                <strong id="userPseudo"></strong>
                <span id="userTeamInfo"></span>
            </div>
            <button class="btn btn-danger" onclick="hdnApp.logout()">üö™ D√©connexion</button>
        </div>

        <!-- Navigation (hidden by default) -->
        <nav class="hidden" id="mainNav">
            <button onclick="hdnApp.showSection('home')">üè† Accueil</button>
            <button id="enigmaNavBtn" onclick="hdnApp.showSection('enigmes')">üí° √ânigmes</button>
            <button onclick="hdnApp.showSection('ranking')">üèÜ Classement</button>
            <button class="hidden" id="minigameNavBtn" onclick="hdnApp.showSection('minigame')">üéÆ Mini-jeu</button>
            <button onclick="hdnApp.showSection('rules')">üìã R√®gles</button>
            <button class="hidden" id="adminNavBtn" onclick="hdnApp.showSection('admin')">‚öôÔ∏è Admin</button>
        </nav>

        <!-- AUTH SECTION -->
        <div class="section active" id="auth-section">
            <div class="card">
                <h2>üîê Bienvenue !</h2>

                <!-- Step 1: Already registered? -->
                <div id="authChoice">
                    <h3 style="text-align: center; margin-bottom: 20px;">√ätes-vous d√©j√† inscrit ?</h3>
                    <div class="auth-choice-container">
                        <div class="auth-choice-btn" onclick="hdnApp.showLogin()">
                            <h3>‚úÖ Oui</h3>
                            <p>Je me connecte</p>
                        </div>
                        <div class="auth-choice-btn" onclick="hdnApp.showRegister()">
                            <h3>‚ùå Non</h3>
                            <p>Je m'inscris</p>
                        </div>
                    </div>
                    <button class="floating-rules-btn" onclick="hdnApp.showRulesModal()">
                        üìã R√®gles du jeu
                    </button>
                </div>

                <!-- Step 2: Login Form (hidden) -->
                <div id="loginForm" class="hidden">
                    <h3>üîë Connexion</h3>
                    <label>Pseudo</label>
                    <input type="text" id="loginPseudo" placeholder="Ton pseudo" />

                    <label>Mot de passe (6 chiffres)</label>
                    <div class="password-container">
                        <input type="password" id="loginPassword" placeholder="123456" maxlength="6"
                               inputmode="numeric" pattern="[0-9]*"
                               oninput="this.value = this.value.replace(/[^0-9]/g, '')" />
                        <button type="button" class="password-toggle"
                                onclick="togglePassword('loginPassword', this)">üëÅÔ∏è</button>
                    </div>

                    <button class="btn btn-success" style="width: 100%; margin-top: 15px;" onclick="hdnApp.login()">
                        üöÄ Se connecter
                    </button>
                    <button class="btn btn-primary" style="width: 100%; margin-top: 10px;"
                            onclick="hdnApp.backToChoice()">
                        ‚Üê Retour
                    </button>
                </div>

                <!-- Step 3: Register Choice (hidden) -->
                <div id="registerChoice" class="hidden">
                    <h3 style="text-align: center; margin-bottom: 20px;">Comment voulez-vous jouer ?</h3>
                    <div class="radio-group">
                        <div class="radio-option" onclick="hdnApp.selectMode('solo')">
                            <input type="radio" name="mode" value="solo" id="modeSolo">
                            <label for="modeSolo" style="cursor: pointer; margin: 0;">
                                <h3 style="color: #343973; margin: 0;">üë§ Solo</h3>
                                <p style="margin-top: 5px; color: #666;">Jouer seul</p>
                            </label>
                        </div>
                        <div class="radio-option" onclick="hdnApp.selectMode('team')">
                            <input type="radio" name="mode" value="team" id="modeTeam">
                            <label for="modeTeam" style="cursor: pointer; margin: 0;">
                                <h3 style="color: #343973; margin: 0;">üë• √âquipe</h3>
                                <p style="margin-top: 5px; color: #666;">Jouer en √©quipe</p>
                            </label>
                        </div>
                    </div>
                    <button class="btn btn-primary" style="width: 100%; margin-top: 10px;"
                            onclick="hdnApp.backToChoice()">
                        ‚Üê Retour
                    </button>
                </div>

                <!-- Solo Registration Form (hidden) -->
                <div id="soloForm" class="hidden">
                    <h3>üìù Inscription Solo</h3>
                    <label>Pseudo *</label>
                    <input type="text" id="soloPseudo" placeholder="Ton pseudo" />

                    <label>Mot de passe (6 chiffres) *</label>
                    <div class="password-container">
                        <input type="password" id="soloPassword" placeholder="123456" maxlength="6"
                               inputmode="numeric" pattern="[0-9]*"
                               oninput="this.value = this.value.replace(/[^0-9]/g, '')" />
                        <button type="button" class="password-toggle"
                                onclick="togglePassword('soloPassword', this)">üëÅÔ∏è</button>
                    </div>

                    <button class="btn btn-success" style="width: 100%; margin-top: 15px;"
                            onclick="hdnApp.registerSolo()">
                        ‚úÖ S'inscrire Solo
                    </button>
                    <button class="btn btn-primary" style="width: 100%; margin-top: 10px;"
                            onclick="hdnApp.backToRegisterChoice()">
                        ‚Üê Retour
                    </button>
                </div>

                <!-- Team Action Selection (hidden) -->
                <div id="teamActionSelection" class="hidden">
                    <h3 style="text-align: center;">√âquipe</h3>
                    <div class="radio-group">
                        <div class="radio-option" onclick="hdnApp.selectTeamAction('create')">
                            <input type="radio" name="teamAction" value="create" id="actionCreate">
                            <label for="actionCreate" style="cursor: pointer; margin: 0;">
                                <h3 style="color: #343973; margin: 0;">‚ûï Cr√©er</h3>
                                <p style="margin-top: 5px; color: #666;">Nouvelle √©quipe</p>
                            </label>
                        </div>
                        <div class="radio-option" onclick="hdnApp.selectTeamAction('join')">
                            <input type="radio" name="teamAction" value="join" id="actionJoin">
                            <label for="actionJoin" style="cursor: pointer; margin: 0;">
                                <h3 style="color: #343973; margin: 0;">üîó Rejoindre</h3>
                                <p style="margin-top: 5px; color: #666;">√âquipe existante</p>
                            </label>
                        </div>
                    </div>
                    <button class="btn btn-primary" style="width: 100%; margin-top: 10px;"
                            onclick="hdnApp.backToRegisterChoice()">
                        ‚Üê Retour
                    </button>
                </div>

                <!-- Create Team Form (hidden) -->
                <div id="createTeamForm" class="hidden">
                    <h3>‚ûï Cr√©er une √âquipe</h3>
                    <label>Nom de l'√©quipe *</label>
                    <input type="text" id="teamName" placeholder="Les champions" />

                    <label>Ton pseudo *</label>
                    <input type="text" id="teamPlayerPseudo" placeholder="Ton pseudo" />

                    <label>Mot de passe (6 chiffres) *</label>
                    <div class="password-container">
                        <input type="password" id="teamPassword" placeholder="123456" maxlength="6"
                               inputmode="numeric" pattern="[0-9]*"
                               oninput="this.value = this.value.replace(/[^0-9]/g, '')" />
                        <button type="button" class="password-toggle"
                                onclick="togglePassword('teamPassword', this)">üëÅÔ∏è</button>
                    </div>

                    <button class="btn btn-success" style="width: 100%; margin-top: 15px;"
                            onclick="hdnApp.createTeam()">
                        üéØ Cr√©er l'√©quipe
                    </button>
                    <button class="btn btn-primary" style="width: 100%; margin-top: 10px;"
                            onclick="hdnApp.backToTeamAction()">
                        ‚Üê Retour
                    </button>
                </div>

                <!-- Join Team Form (hidden) -->
                <div id="joinTeamForm" class="hidden">
                    <h3>üîó Rejoindre une √âquipe</h3>
                    <label>Code de l'√©quipe *</label>
                    <input type="text" id="teamCode" placeholder="Ex: HDN-ABC123" />

                    <label>Ton pseudo *</label>
                    <input type="text" id="joinTeamPseudo" placeholder="Ton pseudo" />

                    <label>Mot de passe (6 chiffres) *</label>
                    <div class="password-container">
                        <input type="password" id="joincreateTeamPassword" placeholder="123456" maxlength="6"
                               inputmode="numeric" pattern="[0-9]*"
                               oninput="this.value = this.value.replace(/[^0-9]/g, '')" />
                        <button type="button" class="password-toggle"
                                onclick="togglePassword('joincreateTeamPassword', this)">üëÅÔ∏è</button>
                    </div>

                    <button class="btn btn-success" style="width: 100%; margin-top: 15px;" onclick="hdnApp.joinTeam()">
                        üöÄ Rejoindre
                    </button>
                    <button class="btn btn-primary" style="width: 100%; margin-top: 10px;"
                            onclick="hdnApp.backToTeamAction()">
                        ‚Üê Retour
                    </button>
                </div>
            </div>
        </div>

        <!-- HOME SECTION -->
        <div class="section" id="home-section">
            <div class="card">
                <h2>üè† Tableau de bord</h2>

                <!-- Anti-IA Block Message (hidden by default) -->
                <div id="antiIaBlockMessage"
                     style="display: none; background: linear-gradient(135deg, #ff4444, #cc0000); border-radius: 10px; padding: 20px; margin-bottom: 20px; text-align: center;">
                    <h3 style="color: white; margin: 0 0 10px 0;">ü§ñ Demander les r√©ponses ne te donnera pas de m√©rite √†
                        √™tre premier !</h3>
                    <p style="color: white; margin: 0 0 15px 0;">Acc√®s aux √©nigmes bloqu√©</p>
                    <div style="background: rgba(0,0,0,0.3); border-radius: 8px; padding: 15px; display: inline-block;">
                        <p style="color: white; margin: 0; font-size: 0.9em;">Temps restant</p>
                        <h2 id="antiIaCountdown" style="color: #81FE0E; margin: 5px 0 0 0; font-size: 2em;">--:--</h2>
                    </div>
                    <p style="color: rgba(255,255,255,0.8); margin: 15px 0 0 0; font-size: 0.85em;">L'√©nigme a √©t√©
                        valid√©e, mais tu as re√ßu une p√©nalit√© de -10 points.</p>
                </div>

                <!-- Countdown Timer -->
                <div class="timer" id="countdownTimer">
                    <p>‚è≥ Aucune √©nigme programm√©e</p>
                </div>

                <!-- User Stats -->
                <div class="stats-grid">
                    <div class="stat-box">
                        <h3 id="userPoints">0</h3>
                        <p>Points</p>
                    </div>
                    <div class="stat-box">
                        <h3 id="userSolved">0</h3>
                        <p>√ânigmes r√©solues</p>
                    </div>
                    <div class="stat-box">
                        <h3 id="userRank">-</h3>
                        <p>Classement</p>
                    </div>
                </div>

                <!-- Profile Settings -->
                <h3 style="margin-top: 30px;">‚öôÔ∏è Mon Profil</h3>
                <div style="display: flex; gap: 10px; flex-wrap: wrap; margin-top: 15px;">
                    <button class="btn btn-primary" onclick="hdnApp.showEditPseudoModal()">‚úèÔ∏è Modifier mon
                        pseudo</button>
                    <button class="btn btn-primary" id="editTeamBtn" onclick="hdnApp.showEditTeamModal()"
                            style="display: none;">üë• Modifier le nom d'√©quipe</button>
                </div>
            </div>
        </div>

        <!-- ENIGMES SECTION -->
        <div class="section" id="enigmes-section">
            <div class="card">
                <h2>üí° √ânigmes</h2>
                <div id="enigmesList" class="loading">Chargement...</div>
            </div>
        </div>

        <!-- RANKING SECTION -->
        <div class="section" id="ranking-section">
            <div class="card">
                <h2>üèÜ Classement</h2>
                <div id="rankingList" class="loading">Chargement...</div>
            </div>
        </div>

        <!-- MINIGAME SECTION -->
        <div class="section" id="minigame-section">
            <div class="card">
                <h2>üéÆ Mini-jeu - Classement</h2>
                <p style="text-align: center; color: #666; margin-bottom: 20px;">
                    Meilleurs temps de l'√âpreuve Finale - Classement individuel
                </p>

                <!-- Bouton pour jouer -->
                <div style="text-align: center; margin-bottom: 25px;">
                    <button class="btn btn-success" style="font-size: 1.1em; padding: 15px 30px;"
                            onclick="hdnApp.playMinigame()">
                        üéÆ Jouer pour le fun !
                    </button>
                    <p style="font-size: 0.85em; color: #888; margin-top: 10px;">
                        Am√©liore ton temps et bats le record !
                    </p>
                </div>

                <div id="minigameLeaderboard" class="loading">Chargement...</div>
            </div>
        </div>

        <!-- RULES SECTION -->
        <div class="section" id="rules-section">
            <div class="card">
                <h2>üìã R√®gles du Jeu</h2>

                <h3>üéØ Objectif</h3>
                <p>R√©sous un maximum d'√©nigmes et scanne les QR Codes pour accumuler des points et grimper dans le
                    classement !</p>

                <h3>‚è∞ Horaires de jeu</h3>
                <ul style="margin-left: 20px; line-height: 2;">
                    <li><strong>En semaine :</strong> 12h-14h (pause d√©j) et 18h-8h (soir/nuit)</li>
                    <li><strong>Le weekend :</strong> 24h/24, pas de restriction !</li>
                </ul>

                <h3>üéÆ Comment jouer ?</h3>
                <ul style="margin-left: 20px; line-height: 2;">
                    <li><strong>√âtape 1 :</strong> R√©sous l'√©nigme et soumets ta r√©ponse</li>
                    <li><strong>√âtape 2 :</strong> Clique sur "Je suis pr√™t" pour r√©v√©ler l'emplacement du QR Code</li>
                    <li><strong>√âtape 3 :</strong> Fonce scanner le QR Code pour gagner tes points !</li>
                </ul>
                <p style="color: #666; font-style: italic; margin-top: 10px;">‚ö†Ô∏è Le chrono bonus d√©marre d√®s que tu
                    cliques sur "Je suis pr√™t", alors fais-le quand tu es vraiment pr√™t √† chercher !</p>

                <h3>üíé Points par position</h3>
                <p>Le classement se fait selon l'ordre de scan du QR Code :</p>
                <ul style="margin-left: 20px; line-height: 2;">
                    <li>ü•á <strong>1er √† scanner :</strong> 125 points</li>
                    <li>ü•à <strong>2√®me :</strong> 100 points</li>
                    <li>ü•â <strong>3√®me :</strong> 75 points</li>
                    <li>üèÖ <strong>4√®me et + :</strong> 50 points</li>
                </ul>

                <h3>‚è±Ô∏è Bonus de rapidit√©</h3>
                <p>Plus tu trouves le QR Code vite apr√®s avoir cliqu√© "Je suis pr√™t", plus tu gagnes :</p>
                <ul style="margin-left: 20px; line-height: 2;">
                    <li>‚ö° <strong>Moins de 20 min :</strong> +20 points</li>
                    <li>üî• <strong>Moins de 40 min :</strong> +10 points</li>
                    <li>‚ú® <strong>Moins de 60 min :</strong> +5 points</li>
                    <li>üòÖ <strong>Plus de 60 min :</strong> pas de bonus</li>
                </ul>

                <h3>üí° Indices</h3>
                <p>Besoin d'aide ? 3 indices sont disponibles par √©nigme, mais ils co√ªtent des points :</p>
                <ul style="margin-left: 20px; line-height: 2;">
                    <li>Indice 1 : <strong>-5 points</strong></li>
                    <li>Indice 2 : <strong>-10 points</strong></li>
                    <li>Indice 3 : <strong>-15 points</strong></li>
                </ul>
                <p style="color: #666; font-style: italic;">Les indices se d√©bloquent dans l'ordre (il faut prendre le 1
                    avant le 2, etc.)</p>

                <h3>üè≥Ô∏è J'abandonne</h3>
                <p>Vraiment bloqu√© ? Tu peux demander la solution pour <strong>-50 points</strong>.</p>
                <p style="color: #666; font-style: italic;">L'√©nigme sera valid√©e et tu pourras passer √† la suivante,
                    mais attention au malus !</p>

                <h3>üîí Mauvaises r√©ponses</h3>
                <ul style="margin-left: 20px; line-height: 2;">
                    <li>Tu as <strong>3 essais</strong> par √©nigme</li>
                    <li>Apr√®s 3 erreurs ‚Üí blocage de <strong>15 minutes</strong></li>
                    <li>R√©fl√©chis bien avant de valider !</li>
                </ul>

                <h3>üë• Mode √âquipe</h3>
                <ul style="margin-left: 20px; line-height: 2;">
                    <li>Les points sont partag√©s : si l'√©quipe gagne 125 pts, chaque membre a 125 pts</li>
                    <li>Si un membre valide l'√©nigme, c'est valid√© pour toute l'√©quipe</li>
                    <li>Pareil pour les indices : un membre d√©bloque = tout le monde voit</li>
                </ul>

                <h3>ü§ñ √Ä propos de l'IA...</h3>
                <p>Les √©nigmes viennent de mon cerveau, alors essayez de vous torturer l'esprit pour y arriver !
                    C'est plus fun de trouver par soi-m√™me, et demander les r√©ponses ne te donnera aucun m√©rite √† √™tre
                    premier üòâ</p>

                <div class="alert alert-info" style="margin-top: 20px;">
                    <strong>üìÖ Dates de l'√©v√©nement :</strong><br>
                    ‚Ä¢ D√©but : 25 novembre 2025<br>
                    ‚Ä¢ Fin : 08 d√©cembre 2025
                </div>
            </div>
        </div>

        <!-- ADMIN SECTION - Content injected dynamically for admins only -->
        <div class="section" id="admin-section"></div>
    </div>

    <script>
        // Configuration Supabase
        const SUPABASE_URL = 'https://kjziudxhzbwhhnwvmlkt.supabase.co';
        const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imtqeml1ZHhoemJ3aGhud3ZtbGt0Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjMzOTg1MTIsImV4cCI6MjA3ODk3NDUxMn0.clKFjIPw6bO_-VI5epj1Fg7TlXUAAeqgYH4bCMS-uP4';

        // Initialize Supabase client
        const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);

        // Toast Notification System
        function showToast(message, type = 'info') {
            // Remove existing toast if any
            const existing = document.querySelector('.toast');
            if (existing) existing.remove();

            // Create toast
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            document.body.appendChild(toast);

            // Auto remove after 4 seconds
            setTimeout(() => {
                toast.style.animation = 'slideUp 0.3s ease-out reverse';
                setTimeout(() => toast.remove(), 300);
            }, 4000);
        }

        // Toggle password visibility
        function togglePassword(inputId, button) {
            const input = document.getElementById(inputId);
            if (input.type === 'password') {
                input.type = 'text';
                button.textContent = 'üôà';
            } else {
                input.type = 'password';
                button.textContent = 'üëÅÔ∏è';
            }
        }

        // Audio upload toggle
        function toggleAudioUpload() {
            const checkbox = document.getElementById('enigmaHasAudio');
            const section = document.getElementById('audioUploadSection');
            section.style.display = checkbox.checked ? 'block' : 'none';
        }

        // Toggle game clues section
        function toggleGameCluesSection() {
            const checkbox = document.getElementById('enigmaHasGame');
            const section = document.getElementById('gameCluesSection');
            section.style.display = checkbox.checked ? 'block' : 'none';
        }

        // Remove audio
        let audioToRemove = false;
        function removeAudio() {
            if (confirm('Supprimer l\'audio de cette √©nigme ?')) {
                audioToRemove = true;
                document.getElementById('currentAudioUrl').style.display = 'none';
                document.getElementById('enigmaAudioFile').value = '';
                showToast('üóëÔ∏è Audio marqu√© pour suppression', 'info');
            }
        }

        // Timezone helper - Convert UTC to Paris time
        function toParisTime(utcDateString) {
            if (!utcDateString) return null;
            const date = new Date(utcDateString);
            return new Date(date.toLocaleString('en-US', { timeZone: 'Europe/Paris' }));
        }

        function formatParisDateTime(utcDateString) {
            if (!utcDateString) return '';
            const date = toParisTime(utcDateString);
            return date.toLocaleString('fr-FR', {
                day: '2-digit',
                month: '2-digit',
                year: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            });
        }

        // ========== SECURITY: Password Hashing ==========
        async function hashPassword(password) {
            const encoder = new TextEncoder();
            const data = encoder.encode(password + 'HDN_SALT_2025');
            const hashBuffer = await crypto.subtle.digest('SHA-256', data);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
        }

        // Main Application
        const hdnApp = {
            currentUser: null,
            selectedMode: null,
            selectedTeamAction: null,
            qrScanner: null,
            countdownInterval: null,
            currentScanEnigmaId: null,

            // Bound drag handlers (initialized in init)
            boundOnDrag: null,
            boundEndDrag: null,

            // Helper to convert local datetime to UTC ISO string
            convertLocalToUTC(localDatetimeString) {
                if (!localDatetimeString) return null;
                const localDate = new Date(localDatetimeString);
                return localDate.toISOString();
            },

            // Check if enigmas are accessible
            // Semaine: 12h-14h ET 18h-8h / Weekend: 24/7
            async isEnigmaAccessAllowed() {
                // Admin can always access
                if (this.currentUser?.is_admin) return true;

                // Test accounts can always access
                if (this.currentUser?.is_test) return true;

                // Check if player is blocked (anti-IA penalty)
                if (this.currentUser?.id) {
                    const { data: player } = await supabase
                        .from('players')
                        .select('enigmas_blocked_until')
                        .eq('id', this.currentUser.id)
                        .maybeSingle();

                    if (player?.enigmas_blocked_until) {
                        const blockEnd = new Date(player.enigmas_blocked_until);
                        const now = new Date();
                        if (now < blockEnd) {
                            const remainingMin = Math.ceil((blockEnd - now) / 60000);
                            this.enigmaBlockMessage = `üîí Acc√®s aux √©nigmes bloqu√© encore ${remainingMin} min`;
                            return false;
                        }
                    }
                }

                const now = new Date();
                const dayOfWeek = now.getDay();
                const hours = now.getHours();

                // Weekend (samedi=6, dimanche=0) = toujours accessible
                if (dayOfWeek === 0 || dayOfWeek === 6) {
                    return true;
                }

                // Semaine = 12h-14h OU 18h-8h (soir/nuit)
                // 12h-14h
                if (hours >= 12 && hours < 14) {
                    return true;
                }
                // 18h-23h59
                if (hours >= 18) {
                    return true;
                }
                // 0h-8h
                if (hours < 8) {
                    return true;
                }

                this.enigmaBlockMessage = '‚è∞ Les √©nigmes sont accessibles entre 12h-14h et 18h-8h en semaine, et 24h/24 le weekend !';
                return false;
            },

            // Update enigma button state
            async updateEnigmaButtonState() {

                const enigmaBtn = document.getElementById('enigmaNavBtn');
                console.log('Bouton trouv√©:', enigmaBtn);

                if (!enigmaBtn) {
                    console.error('‚ùå Bouton √ânigmes non trouv√© !');
                    return;
                }

                const isAllowed = await this.isEnigmaAccessAllowed();
                console.log('Acc√®s autoris√©:', isAllowed);

                if (isAllowed) {
                    console.log('‚úÖ D√©verrouillage du bouton');
                    // D√©verrouiller
                    enigmaBtn.disabled = false;
                    enigmaBtn.style.opacity = '1';
                    enigmaBtn.style.cursor = 'pointer';
                    enigmaBtn.onclick = () => this.showSection('enigmes');
                } else {
                    console.log('üîí Verrouillage du bouton');
                    // Verrouiller
                    enigmaBtn.disabled = true;
                    enigmaBtn.style.opacity = '0.5';
                    enigmaBtn.style.cursor = 'not-allowed';
                    enigmaBtn.style.pointerEvents = 'auto';
                    const blockMsg = this.enigmaBlockMessage || '‚è∞ Les √©nigmes sont accessibles entre 12h-14h et 18h-8h en semaine, et 24h/24 le weekend !';
                    enigmaBtn.onclick = (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        showToast(blockMsg, 'warning');
                    };
                }



                console.log('√âtat final du bouton:', {
                    disabled: enigmaBtn.disabled,
                    opacity: enigmaBtn.style.opacity,
                    cursor: enigmaBtn.style.cursor
                });
            },

            showRulesModal() {
                // Create modal
                const modal = document.createElement('div');
                modal.className = 'rules-modal';
                modal.onclick = (e) => {
                    if (e.target === modal) this.closeRulesModal();
                };

                modal.innerHTML = `
        <div class="rules-modal-content">
            <button class="rules-modal-close" onclick="hdnApp.closeRulesModal()">√ó</button>
            <div id="modalRulesContent"></div>
        </div>
    `;

                document.body.appendChild(modal);

                // Copy rules content
                const rulesSection = document.getElementById('rules-section');
                const modalContent = document.getElementById('modalRulesContent');
                modalContent.innerHTML = rulesSection.innerHTML;
            },

            closeRulesModal() {
                const modal = document.querySelector('.rules-modal');
                if (modal) {
                    modal.remove();
                }
            },

            async init() {
                console.log('üéÑ HDN Christmas App Starting...');

                // Bind drag handlers to preserve 'this' context
                this.boundOnDrag = this.onDrag.bind(this);
                this.boundEndDrag = this.endDrag.bind(this);

                // Check if user is logged in
                const savedUser = localStorage.getItem('hdnCurrentUser');
                if (savedUser) {
                    this.currentUser = JSON.parse(savedUser);
                    await this.loadUserData();
                    this.showMainApp();
                }

                // Start countdown timer
                this.startCountdown();
            },

            // ========== AUTH FLOW ==========

            showLogin() {
                document.getElementById('authChoice').classList.add('hidden');
                document.getElementById('loginForm').classList.remove('hidden');
            },

            showRegister() {
                document.getElementById('authChoice').classList.add('hidden');
                document.getElementById('registerChoice').classList.remove('hidden');
            },

            backToChoice() {
                document.getElementById('loginForm').classList.add('hidden');
                document.getElementById('registerChoice').classList.add('hidden');
                document.getElementById('authChoice').classList.remove('hidden');

                // Clear fields
                document.getElementById('loginPseudo').value = '';
                document.getElementById('loginPassword').value = '';
            },

            backToRegisterChoice() {
                document.getElementById('soloForm').classList.add('hidden');
                document.getElementById('teamActionSelection').classList.add('hidden');
                document.getElementById('registerChoice').classList.remove('hidden');
                // Clear fields
                document.getElementById('soloPseudo').value = '';
                document.getElementById('soloPassword').value = '';
            },

            backToTeamAction() {
                document.getElementById('createTeamForm').classList.add('hidden');
                document.getElementById('joinTeamForm').classList.add('hidden');
                document.getElementById('teamActionSelection').classList.remove('hidden');
            },

            selectMode(mode) {
                this.selectedMode = mode;

                // Update UI
                document.querySelectorAll('#registerChoice .radio-option').forEach(opt => {
                    opt.classList.remove('active');
                });
                event.target.closest('.radio-option').classList.add('active');

                // Show appropriate form
                if (mode === 'solo') {
                    document.getElementById('registerChoice').classList.add('hidden');
                    document.getElementById('soloForm').classList.remove('hidden');
                    document.getElementById('teamActionSelection').classList.add('hidden');
                } else if (mode === 'team') {
                    document.getElementById('registerChoice').classList.add('hidden');
                    document.getElementById('teamActionSelection').classList.remove('hidden');
                    document.getElementById('soloForm').classList.add('hidden');
                }
            },

            selectTeamAction(action) {
                this.selectedTeamAction = action;

                // Update UI
                document.querySelectorAll('#teamActionSelection .radio-option').forEach(opt => {
                    opt.classList.remove('active');
                });
                event.target.closest('.radio-option').classList.add('active');

                // Show appropriate form
                setTimeout(() => {
                    document.getElementById('teamActionSelection').classList.add('hidden');
                    if (action === 'create') {
                        document.getElementById('createTeamForm').classList.remove('hidden');
                    } else {
                        document.getElementById('joinTeamForm').classList.remove('hidden');
                    }
                }, 200);
            },

            // ========== REGISTRATION ==========

            async registerSolo() {
                const pseudo = document.getElementById('soloPseudo').value.trim();
                const password = document.getElementById('soloPassword').value;

                if (!pseudo || !password) {
                    showToast('Veuillez remplir tous les champs', 'error');
                    return;
                }

                if (password.length !== 6 || !/^\d+$/.test(password)) {
                    showToast('Le mot de passe doit contenir exactement 6 chiffres', 'error');
                    return;
                }

                try {
                    // Hash password before storing
                    const hashedPassword = await hashPassword(password);

                    // Cr√©er le joueur avec type 'solo'
                    const { data: player, error: playerError } = await supabase
                        .from('players')
                        .insert([{
                            pseudo: pseudo,
                            password: hashedPassword,
                            type: 'solo',
                            points: 0,
                            is_test: false
                        }])
                        .select('id, pseudo, type, points, team_id, is_admin, is_test')
                        .single();

                    if (playerError) throw playerError;

                    // Stocker les infos et se connecter
                    localStorage.setItem('playerId', player.id);
                    localStorage.setItem('playerPseudo', player.pseudo);
                    localStorage.setItem('playerType', 'solo');

                    // Stocker la session et se connecter
                    this.currentUser = player;
                    localStorage.setItem('hdnCurrentUser', JSON.stringify(player));

                    showToast('Inscription r√©ussie ! Bienvenue ' + player.pseudo + ' !', 'success');

                    await this.loadUserData();
                    this.showMainApp();

                } catch (error) {
                    console.error('Erreur inscription solo:', error);
                    if (error.code === '23505') {
                        showToast('Ce pseudo est d√©j√† utilis√©', 'error');
                    } else {
                        showToast('Erreur lors de l\'inscription : ' + error.message, 'error');
                    }
                }
            },

            async createTeam() {
                const teamName = document.getElementById('teamName').value.trim();
                const playerPseudo = document.getElementById('teamPlayerPseudo').value.trim();
                const password = document.getElementById('teamPassword').value;

                if (!teamName || !playerPseudo || !password) {
                    showToast('Veuillez remplir tous les champs', 'error');
                    return;
                }

                if (password.length !== 6 || !/^\d+$/.test(password)) {
                    showToast('Le mot de passe doit contenir exactement 6 chiffres', 'error');
                    return;
                }

                try {
                    // V√©rifier si le pseudo existe d√©j√†
                    const { data: existing } = await supabase
                        .from('players')
                        .select('id')
                        .eq('pseudo', playerPseudo)
                        .maybeSingle();

                    if (existing) {
                        showToast('‚ùå Ce pseudo existe d√©j√† !', 'error');
                        return;
                    }

                    // G√©n√©rer un code unique pour l'√©quipe
                    const teamCode = Math.random().toString(36).substring(2, 8).toUpperCase();

                    // Hash password before storing
                    const hashedPassword = await hashPassword(password);

                    // 1. Cr√©er le joueur SANS team_id d'abord
                    const { data: player, error: playerError } = await supabase
                        .from('players')
                        .insert([{
                            pseudo: playerPseudo,
                            password: hashedPassword,
                            type: 'team',
                            team_id: null,
                            points: 0,
                            is_admin: false,
                            is_test: false
                        }])
                        .select('id, pseudo, type, points, team_id, is_admin, is_test')
                        .single();

                    if (playerError) throw playerError;

                    // 2. Cr√©er l'√©quipe avec le leader
                    const { data: team, error: teamError } = await supabase
                        .from('teams')
                        .insert([{
                            name: teamName,
                            code: teamCode,
                            leader: player.id
                        }])
                        .select()
                        .single();

                    if (teamError) {
                        // Si erreur, supprimer le joueur cr√©√©
                        await supabase.from('players').delete().eq('id', player.id);
                        throw teamError;
                    }

                    // 3. Mettre √† jour le joueur avec team_id
                    const { error: updateError } = await supabase
                        .from('players')
                        .update({ team_id: team.id })
                        .eq('id', player.id);

                    if (updateError) {
                        // Nettoyer si erreur
                        await supabase.from('teams').delete().eq('id', team.id);
                        await supabase.from('players').delete().eq('id', player.id);
                        throw updateError;
                    }

                    // Mettre √† jour l'objet player localement
                    player.team_id = team.id;

                    // Stocker la session
                    this.currentUser = player;
                    localStorage.setItem('hdnCurrentUser', JSON.stringify(player));

                    showToast('‚úÖ √âquipe cr√©√©e ! Code : ' + team.code, 'success');

                    await this.loadUserData();
                    this.showMainApp();

                } catch (error) {
                    console.error('Erreur cr√©ation √©quipe:', error);
                    if (error.code === '23505') {
                        showToast('‚ùå Ce pseudo est d√©j√† utilis√©', 'error');
                    } else {
                        showToast('‚ùå Erreur lors de la cr√©ation : ' + error.message, 'error');
                    }
                }
            },

            async joinTeam() {
                const teamCode = document.getElementById('teamCode').value.trim();
                const pseudo = document.getElementById('joinTeamPseudo').value.trim();
                const password = document.getElementById('joincreateTeamPassword').value.trim();

                if (!teamCode || !pseudo || !password) {
                    showToast('‚ùå Remplis tous les champs !', 'error');
                    return;
                }

                if (password.length !== 6 || !/^\d{6}$/.test(password)) {
                    showToast('‚ùå Le mot de passe doit contenir exactement 6 chiffres !', 'error');
                    return;
                }

                try {
                    // Find team (only get non-sensitive columns)
                    const { data: team, error: teamError } = await supabase
                        .from('teams')
                        .select('id, name, code, points')
                        .eq('code', teamCode.toUpperCase())
                        .maybeSingle();

                    if (!team) {
                        showToast('‚ùå Code d\'√©quipe invalide !', 'error');
                        return;
                    }

                    // Check if pseudo exists
                    const { data: existing } = await supabase
                        .from('players')
                        .select('id')
                        .eq('pseudo', pseudo)
                        .maybeSingle();

                    if (existing) {
                        showToast('‚ùå Ce pseudo existe d√©j√† !', 'error');
                        return;
                    }

                    // Hash password before storing
                    const hashedPassword = await hashPassword(password);

                    // Create player
                    const { data: player, error: playerError } = await supabase
                        .from('players')
                        .insert([{
                            pseudo: pseudo,
                            password: hashedPassword,
                            team_id: team.id,
                            points: 0,
                            is_admin: false,
                            is_test: false,
                            type: 'team'
                        }])
                        .select('id, pseudo, type, points, team_id, is_admin, is_test')
                        .single();

                    if (playerError) throw playerError;

                    showToast(`‚úÖ Tu as rejoint l'√©quipe "${team.name}" !`, 'success');

                    // Auto login
                    this.currentUser = player;
                    localStorage.setItem('hdnCurrentUser', JSON.stringify(player));
                    await this.loadUserData();
                    this.showMainApp();

                } catch (error) {
                    console.error('Error:', error);
                    showToast('‚ùå Erreur lors de la connexion √† l\'√©quipe : ' + error.message, 'error');
                }
            },

            // ========== LOGIN ==========

            async login() {
                const pseudo = document.getElementById('loginPseudo').value.trim();
                const password = document.getElementById('loginPassword').value.trim();

                if (!pseudo || !password) {
                    showToast('‚ùå Remplis tous les champs !', 'error');
                    return;
                }

                try {
                    // Hash password before comparing
                    const hashedPassword = await hashPassword(password);

                    const { data: player, error } = await supabase
                        .from('players')
                        .select('id, pseudo, type, points, team_id, is_admin, is_test')
                        .eq('pseudo', pseudo)
                        .eq('password', hashedPassword)
                        .maybeSingle();

                    if (!player) {
                        showToast('‚ùå Pseudo ou mot de passe incorrect !', 'error');
                        return;
                    }

                    // Login successful
                    this.currentUser = player;
                    localStorage.setItem('hdnCurrentUser', JSON.stringify(player));
                    await this.loadUserData();
                    this.showMainApp();

                    showToast('‚úÖ Connexion r√©ussie !', 'success');

                } catch (error) {
                    console.error('Error:', error);
                    showToast('‚ùå Erreur lors de la connexion', 'error');
                }
            },

            // ========== USER DATA ==========

            async loadUserData() {
                if (!this.currentUser) return;

                try {
                    // Reload fresh user data (without password) - include enigmas_blocked_until
                    const { data: player } = await supabase
                        .from('players')
                        .select('id, pseudo, type, points, team_id, is_admin, is_test, enigmas_blocked_until')
                        .eq('id', this.currentUser.id)
                        .maybeSingle();

                    if (player) {
                        this.currentUser = player;
                        localStorage.setItem('hdnCurrentUser', JSON.stringify(player));
                    }

                    // Update UI
                    document.getElementById('userPseudo').textContent = this.currentUser.pseudo;
                    document.getElementById('userPoints').textContent = this.currentUser.points || 0;

                    // Check and display anti-IA block message
                    await this.checkAndDisplayAntiIaBlock();

                    // Load team info if applicable (without sensitive data)
                    if (this.currentUser.team_id) {
                        const { data: team } = await supabase
                            .from('teams')
                            .select('id, name, code, points, leader')
                            .eq('id', this.currentUser.team_id)
                            .maybeSingle();

                        if (team) {
                            document.getElementById('userTeamInfo').textContent = `√âquipe: ${team.name} - Code: ${team.code}`;

                            // Show edit team button if user is leader (compare as strings to avoid type mismatch)
                            const editTeamBtn = document.getElementById('editTeamBtn');
                            if (editTeamBtn && String(team.leader) === String(this.currentUser.id)) {
                                editTeamBtn.style.display = 'inline-block';
                            }
                        }
                    } else {
                        document.getElementById('userTeamInfo').textContent = 'Solo';
                    }

                    // Load solved enigmas count
                    let query = supabase
                        .from('enigma_progress')
                        .select('id', { count: 'exact' })
                        .eq('solved', true);

                    if (this.currentUser.team_id) {
                        query = query.eq('team_id', this.currentUser.team_id);
                    } else {
                        query = query.eq('player_id', this.currentUser.id);
                    }

                    const { count } = await query;
                    document.getElementById('userSolved').textContent = count || 0;

                    // Calculate rank
                    await this.calculateRank();

                } catch (error) {
                    console.error('Error loading user data:', error);
                }
            },

            // Anti-IA block display with countdown
            antiIaCountdownInterval: null,

            async checkAndDisplayAntiIaBlock() {
                const blockMessage = document.getElementById('antiIaBlockMessage');
                const countdownEl = document.getElementById('antiIaCountdown');

                if (!blockMessage || !countdownEl) return;

                // Clear existing interval
                if (this.antiIaCountdownInterval) {
                    clearInterval(this.antiIaCountdownInterval);
                    this.antiIaCountdownInterval = null;
                }

                // Check if blocked
                if (this.currentUser?.enigmas_blocked_until) {
                    const blockEnd = new Date(this.currentUser.enigmas_blocked_until);
                    const now = new Date();

                    if (now < blockEnd) {
                        // Still blocked - show message and start countdown
                        blockMessage.style.display = 'block';

                        const updateCountdown = () => {
                            const now = new Date();
                            const remaining = blockEnd - now;

                            if (remaining <= 0) {
                                // Block expired
                                blockMessage.style.display = 'none';
                                clearInterval(this.antiIaCountdownInterval);
                                this.antiIaCountdownInterval = null;
                                // Clear the block in database
                                supabase
                                    .from('players')
                                    .update({ enigmas_blocked_until: null })
                                    .eq('id', this.currentUser.id)
                                    .then(() => {
                                        this.currentUser.enigmas_blocked_until = null;
                                    });
                                return;
                            }

                            const minutes = Math.floor(remaining / 60000);
                            const seconds = Math.floor((remaining % 60000) / 1000);
                            countdownEl.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                        };

                        // Update immediately and then every second
                        updateCountdown();
                        this.antiIaCountdownInterval = setInterval(updateCountdown, 1000);
                    } else {
                        // Block expired
                        blockMessage.style.display = 'none';
                    }
                } else {
                    // Not blocked
                    blockMessage.style.display = 'none';
                }
            },

            async calculateRank() {
                try {
                    // Get all non-test players/teams ranked by points
                    if (this.currentUser.team_id) {
                        // Team ranking
                        const { data: teams } = await supabase
                            .from('teams')
                            .select('id, points')
                            .order('points', { ascending: false });

                        const rank = teams.findIndex(t => t.id === this.currentUser.team_id) + 1;
                        document.getElementById('userRank').textContent = rank > 0 ? rank : '-';
                    } else {
                        // Solo ranking (exclude test accounts)
                        const { data: players } = await supabase
                            .from('players')
                            .select('id, points, is_test')
                            .is('team_id', null)
                            .eq('is_test', false)
                            .order('points', { ascending: false });

                        const rank = players.findIndex(p => p.id === this.currentUser.id) + 1;
                        document.getElementById('userRank').textContent = rank > 0 ? rank : '-';
                    }
                } catch (error) {
                    console.error('Error calculating rank:', error);
                }
            },

            async showMainApp() {
                // Hide auth section
                document.getElementById('auth-section').classList.remove('active');

                // Show user info and nav
                document.getElementById('userInfo').classList.remove('hidden');
                document.getElementById('mainNav').classList.remove('hidden');

                // Show admin button and inject admin template if admin
                if (this.currentUser.is_admin) {
                    document.getElementById('adminNavBtn').classList.remove('hidden');
                    // Inject admin template dynamically
                    document.getElementById('admin-section').innerHTML = this.getAdminTemplate();
                    // Hide floating rules button
                    const floatingRulesBtn = document.querySelector('.floating-rules-btn');
                    if (floatingRulesBtn) {
                        floatingRulesBtn.style.display = 'none';
                    }
                }

                // V√©rifier si l'onglet mini-jeu doit √™tre affich√©
                await this.checkMinigameAccess();

                // Show home section
                this.showSection('home');
            },

            // Admin template - hidden from View Source for non-admins
            getAdminTemplate() {
                return `
                <div class="card">
                    <h2>‚öôÔ∏è Administration</h2>

                    <h3>üìä Statistiques</h3>
                    <div class="stats-grid">
                        <div class="stat-box">
                            <h3 id="adminTotalPlayers">0</h3>
                            <p>Joueurs</p>
                        </div>
                        <div class="stat-box">
                            <h3 id="adminTotalEnigmas">0</h3>
                            <p>√ânigmes</p>
                        </div>
                        <div class="stat-box">
                            <h3 id="adminPendingValidations">0</h3>
                            <p>En attente</p>
                        </div>
                    </div>

                    <h3>‚ûï Cr√©er une √ânigme</h3>

                    <label>Titre *</label>
                    <input type="text" id="enigmaTitle" placeholder="Titre de l'√©nigme" />

                    <label>Description *</label>
                    <textarea id="enigmaDescription" rows="4" placeholder="√ânonc√© de l'√©nigme"></textarea>

                    <label>Image (URL optionnelle)</label>
                    <input type="url" id="enigmaImageUrl" placeholder="https://example.com/image.jpg" />
                    <p style="font-size: 0.85em; color: #666; margin-top: 5px;">
                        URL de l'image √† afficher avec l'√©nigme (optionnel)
                    </p>

                    <h3>üéµ Audio (optionnel)</h3>
                    <label>
                        <input type="checkbox" id="enigmaHasAudio" style="width: auto; margin-right: 10px;" onchange="toggleAudioUpload()" />
                        Cette √©nigme contient un message audio
                    </label>
                    <div id="audioUploadSection" style="display: none; margin-top: 15px; padding: 15px; background: #f0f8ff; border-radius: 8px; border: 1px dashed #343973;">
                        <label>Fichier audio (MP3)</label>
                        <input type="file" id="enigmaAudioFile" accept="audio/mp3,audio/mpeg" style="padding: 10px; background: white; border-radius: 5px;" />
                        <p style="font-size: 0.85em; color: #666; margin-top: 5px;">
                            üí° Le fichier sera upload√© automatiquement lors de la sauvegarde
                        </p>
                        <div id="currentAudioUrl" style="display: none; margin-top: 10px; padding: 10px; background: #e8f5e9; border-radius: 5px;">
                            <span style="color: #2e7d32;">‚úÖ Audio actuel :</span>
                            <a id="currentAudioLink" href="#" target="_blank" style="color: #343973; word-break: break-all;"></a>
                            <button type="button" onclick="removeAudio()" style="margin-left: 10px; padding: 5px 10px; background: #ff4444; color: white; border: none; border-radius: 5px; cursor: pointer;">üóëÔ∏è Supprimer</button>
                        </div>
                    </div>

                    <label>R√©ponse *</label>
                    <input type="text" id="enigmaAnswer" placeholder="R√©ponse correcte" />

                    <label>Emplacement du QR Code *</label>
                    <input type="text" id="enigmaLocation" placeholder="Ex: Pr√®s de la fontaine, 2√®me √©tage..." />

                    <label>Type de validation</label>
                    <select id="enigmaValidation">
                        <option value="auto">Automatique</option>
                        <option value="manual">Manuelle</option>
                    </select>

                    <h3>üéÆ √âpreuve Finale (optionnel)</h3>
                    <label>
                        <input type="checkbox" id="enigmaHasGame" style="width: auto; margin-right: 10px;" onchange="toggleGameCluesSection()" />
                        Cette √©nigme inclut le jeu "√âpreuve Finale" avant le QR Code
                    </label>
                    <p style="font-size: 0.85em; color: #666; margin-top: 5px;">
                        ‚ö†Ô∏è Si coch√©, le joueur devra compl√©ter le jeu de plateforme avant de pouvoir chercher le QR Code.
                        Le score du jeu donne des points bonus.
                    </p>

                    <!-- Section indices du jeu (cach√©e par d√©faut) -->
                    <div id="gameCluesSection" style="display: none; margin-top: 15px; padding: 20px; background: linear-gradient(135deg, #1a1a2e, #16213e); border: 2px solid #81FE0E; border-radius: 10px;">
                        <h4 style="color: #81FE0E; margin: 0 0 15px 0;">üîç Indices cach√©s dans le jeu</h4>
                        <p style="color: #fff; font-size: 0.85em; margin-bottom: 15px;">
                            Configure les 4 indices que les joueurs d√©couvriront en compl√©tant les niveaux.
                        </p>
                        
                        <div style="display: grid; gap: 15px;">
                            <div style="display: flex; gap: 10px; align-items: center;">
                                <select id="gameClueLevel1" style="width: 120px; padding: 8px;">
                                    <option value="3">Niveau 3</option>
                                    <option value="4">Niveau 4</option>
                                    <option value="5">Niveau 5</option>
                                    <option value="6">Niveau 6</option>
                                </select>
                                <input type="text" id="gameClue1" placeholder="Indice 1 (ex: NOEL)" style="flex: 1;" />
                            </div>
                            <div style="display: flex; gap: 10px; align-items: center;">
                                <select id="gameClueLevel2" style="width: 120px; padding: 8px;">
                                    <option value="5">Niveau 5</option>
                                    <option value="6">Niveau 6</option>
                                    <option value="7">Niveau 7</option>
                                    <option value="8">Niveau 8</option>
                                </select>
                                <input type="text" id="gameClue2" placeholder="Indice 2" style="flex: 1;" />
                            </div>
                            <div style="display: flex; gap: 10px; align-items: center;">
                                <select id="gameClueLevel3" style="width: 120px; padding: 8px;">
                                    <option value="8">Niveau 8</option>
                                    <option value="9">Niveau 9</option>
                                    <option value="10">Niveau 10</option>
                                    <option value="11">Niveau 11</option>
                                </select>
                                <input type="text" id="gameClue3" placeholder="Indice 3" style="flex: 1;" />
                            </div>
                            <div style="display: flex; gap: 10px; align-items: center;">
                                <select id="gameClueLevel4" style="width: 120px; padding: 8px;">
                                    <option value="10">Niveau 10</option>
                                    <option value="11">Niveau 11</option>
                                    <option value="12" selected>Niveau 12</option>
                                </select>
                                <input type="text" id="gameClue4" placeholder="Indice 4" style="flex: 1;" />
                            </div>
                        </div>
                    </div>

                    <h3>üí° Indices (optionnels)</h3>
                    <label>Indice 1</label>
                    <textarea id="enigmaHint1" rows="2" placeholder="Premier indice (-5 points)"></textarea>

                    <label>Indice 2</label>
                    <textarea id="enigmaHint2" rows="2" placeholder="Deuxi√®me indice (-10 points)"></textarea>

                    <label>Indice 3</label>
                    <textarea id="enigmaHint3" rows="2" placeholder="Troisi√®me indice (-15 points)"></textarea>

                    <h3>üìÖ Publication</h3>
                    <label>
                        <input type="checkbox" id="enigmaPublished" style="width: auto; margin-right: 10px;" />
                        Publier imm√©diatement
                    </label>

                    <div id="schedulePublishDiv" style="margin-top: 15px;">
                        <label>üìÖ Programmer la publication (optionnel)</label>
                        <input type="datetime-local" id="enigmaSchedule" />
                        <p style="font-size: 0.85em; color: #666; margin-top: 5px;">
                            Si rempli, l'√©nigme sera automatiquement publi√©e √† cette date/heure
                        </p>
                    </div>

                    <button class="btn btn-success" style="width: 100%; margin-top: 15px;" onclick="hdnApp.createEnigma()">
                        ‚úÖ Cr√©er l'√©nigme
                    </button>

                    <h3 style="margin-top: 30px;">üìã Mes √ânigmes</h3>
                    <div id="adminEnigmasList"></div>

                    <h3 style="margin-top: 30px;">‚úÖ Validations en attente</h3>
                    <div id="pendingValidationsList"></div>

                    <h3 style="margin-top: 30px;">üíæ Export des donn√©es</h3>
                    <button class="btn btn-primary" style="width: 100%;" onclick="hdnApp.exportData()">
                        üì• Exporter toutes les donn√©es
                    </button>
                </div>
                `;
            },

            // ========== EDIT PSEUDO ==========

            showEditPseudoModal() {
                const modal = document.createElement('div');
                modal.id = 'editPseudoModal';
                modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 10000; display: flex; align-items: center; justify-content: center; padding: 20px;';
                modal.innerHTML = `
                    <div style="background: white; padding: 30px; border-radius: 15px; max-width: 400px; width: 100%;">
                        <h3 style="color: #343973; margin-bottom: 20px;">‚úèÔ∏è Modifier mon pseudo</h3>
                        <p style="color: #666; margin-bottom: 15px;">Pseudo actuel : <strong>${this.currentUser.pseudo}</strong></p>
                        <input type="text" id="newPseudoInput" placeholder="Nouveau pseudo" style="width: 100%; padding: 12px; border: 2px solid #343973; border-radius: 8px; font-family: 'Orbitron', sans-serif; margin-bottom: 15px;">
                        <div style="display: flex; gap: 10px; justify-content: flex-end;">
                            <button class="btn btn-danger" onclick="hdnApp.closeEditPseudoModal()">Annuler</button>
                            <button class="btn btn-success" onclick="hdnApp.savePseudo()">Enregistrer</button>
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
                document.getElementById('newPseudoInput').focus();
            },

            closeEditPseudoModal() {
                const modal = document.getElementById('editPseudoModal');
                if (modal) modal.remove();
            },

            async savePseudo() {
                const newPseudo = document.getElementById('newPseudoInput').value.trim();

                if (!newPseudo) {
                    showToast('‚ùå Le pseudo ne peut pas √™tre vide !', 'error');
                    return;
                }

                if (newPseudo === this.currentUser.pseudo) {
                    showToast('‚ö†Ô∏è C\'est d√©j√† ton pseudo actuel !', 'warning');
                    return;
                }

                try {
                    // Check if pseudo already exists
                    const { data: existing } = await supabase
                        .from('players')
                        .select('id')
                        .eq('pseudo', newPseudo)
                        .neq('id', this.currentUser.id)
                        .maybeSingle();

                    if (existing) {
                        showToast('‚ùå Ce pseudo est d√©j√† utilis√© !', 'error');
                        return;
                    }

                    // Update pseudo
                    const { error } = await supabase
                        .from('players')
                        .update({ pseudo: newPseudo })
                        .eq('id', this.currentUser.id);

                    if (error) throw error;

                    showToast('‚úÖ Pseudo modifi√© avec succ√®s !', 'success');
                    this.closeEditPseudoModal();
                    await this.loadUserData();

                } catch (error) {
                    console.error('Error updating pseudo:', error);
                    showToast('‚ùå Erreur lors de la modification : ' + error.message, 'error');
                }
            },

            // ========== EDIT TEAM NAME ==========

            showEditTeamModal() {
                if (!this.currentUser.team_id) {
                    showToast('‚ùå Tu n\'es pas dans une √©quipe !', 'error');
                    return;
                }

                // Get current team name
                supabase
                    .from('teams')
                    .select('name, leader')
                    .eq('id', this.currentUser.team_id)
                    .single()
                    .then(({ data: team, error }) => {
                        if (error || !team) {
                            showToast('‚ùå √âquipe non trouv√©e !', 'error');
                            return;
                        }

                        if (String(team.leader) !== String(this.currentUser.id)) {
                            showToast('‚ùå Seul le leader peut modifier le nom de l\'√©quipe !', 'error');
                            return;
                        }

                        const modal = document.createElement('div');
                        modal.id = 'editTeamModal';
                        modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 10000; display: flex; align-items: center; justify-content: center; padding: 20px;';
                        modal.innerHTML = `
                            <div style="background: white; padding: 30px; border-radius: 15px; max-width: 400px; width: 100%;">
                                <h3 style="color: #343973; margin-bottom: 20px;">üë• Modifier le nom d'√©quipe</h3>
                                <p style="color: #666; margin-bottom: 15px;">Nom actuel : <strong>${team.name}</strong></p>
                                <input type="text" id="newTeamNameInput" placeholder="Nouveau nom d'√©quipe" style="width: 100%; padding: 12px; border: 2px solid #343973; border-radius: 8px; font-family: 'Orbitron', sans-serif; margin-bottom: 15px;">
                                <div style="display: flex; gap: 10px; justify-content: flex-end;">
                                    <button class="btn btn-danger" onclick="hdnApp.closeEditTeamModal()">Annuler</button>
                                    <button class="btn btn-success" onclick="hdnApp.saveTeamName()">Enregistrer</button>
                                </div>
                            </div>
                        `;
                        document.body.appendChild(modal);
                        document.getElementById('newTeamNameInput').focus();
                    });
            },

            closeEditTeamModal() {
                const modal = document.getElementById('editTeamModal');
                if (modal) modal.remove();
            },

            async saveTeamName() {
                const newName = document.getElementById('newTeamNameInput').value.trim();

                if (!newName) {
                    showToast('‚ùå Le nom d\'√©quipe ne peut pas √™tre vide !', 'error');
                    return;
                }

                try {
                    // Check if team name already exists
                    const { data: existing } = await supabase
                        .from('teams')
                        .select('id')
                        .eq('name', newName)
                        .neq('id', this.currentUser.team_id)
                        .maybeSingle();

                    if (existing) {
                        showToast('‚ùå Ce nom d\'√©quipe est d√©j√† utilis√© !', 'error');
                        return;
                    }

                    // Update team name
                    const { error } = await supabase
                        .from('teams')
                        .update({ name: newName })
                        .eq('id', this.currentUser.team_id);

                    if (error) throw error;

                    showToast('‚úÖ Nom d\'√©quipe modifi√© avec succ√®s !', 'success');
                    this.closeEditTeamModal();
                    await this.loadUserData();

                } catch (error) {
                    console.error('Error updating team name:', error);
                    showToast('‚ùå Erreur lors de la modification : ' + error.message, 'error');
                }
            },

            logout() {
                if (confirm('Veux-tu vraiment te d√©connecter ?')) {
                    localStorage.removeItem('hdnCurrentUser');
                    location.reload();
                }
            },

            // ========== NAVIGATION ==========

            async showSection(sectionName) {
                // Check enigma access
                if (sectionName === 'enigmes') {
                    const isAllowed = await this.isEnigmaAccessAllowed();
                    if (!isAllowed) {
                        const blockMsg = this.enigmaBlockMessage || '‚è∞ Les √©nigmes sont accessibles entre 12h-14h et 18h-8h en semaine, et 24h/24 le weekend !';
                        showToast(blockMsg, 'warning');
                        return;
                    }
                }

                // Hide all sections
                document.querySelectorAll('.section').forEach(section => {
                    section.classList.remove('active');
                });

                // Remove active class from all nav buttons
                document.querySelectorAll('nav button').forEach(btn => {
                    btn.classList.remove('active');
                });

                // Show selected section
                document.getElementById(`${sectionName}-section`).classList.add('active');

                // Highlight active nav button
                event?.target?.classList.add('active');

                // Load section data
                if (sectionName === 'enigmes') {
                    this.loadEnigmes();
                } else if (sectionName === 'ranking') {
                    this.loadClassement();
                } else if (sectionName === 'minigame') {
                    this.loadGameLeaderboard();
                } else if (sectionName === 'admin') {
                    this.loadAdminPanel();
                } else if (sectionName === 'home') {
                    this.loadUserData();
                }

                // Start or stop time access checker based on section
                if (sectionName === 'enigmes') {
                    this.startTimeAccessChecker();
                } else {
                    this.stopTimeAccessChecker();
                }
            },

            // ========== TIME ACCESS CHECKER ==========
            timeAccessInterval: null,

            startTimeAccessChecker() {
                // Clear any existing interval
                this.stopTimeAccessChecker();

                // Check every 30 seconds if still within allowed hours
                this.timeAccessInterval = setInterval(async () => {
                    const isAllowed = await this.isEnigmaAccessAllowed();
                    if (!isAllowed) {
                        this.stopTimeAccessChecker();
                        showToast(this.enigmaBlockMessage || '‚è∞ Les horaires d\'acc√®s aux √©nigmes sont termin√©s !', 'warning');
                        this.showSection('home');
                    }
                }, 30000); // Check every 30 seconds
            },

            stopTimeAccessChecker() {
                if (this.timeAccessInterval) {
                    clearInterval(this.timeAccessInterval);
                    this.timeAccessInterval = null;
                }
            },

            // ========== COUNTDOWN TIMER ==========

            startCountdown() {
                if (this.countdownInterval) {
                    clearInterval(this.countdownInterval);
                }

                this.updateCountdown();
                this.countdownInterval = setInterval(() => this.updateCountdown(), 1000);
            },

            async updateCountdown() {
                try {
                    // Get next scheduled enigma (without sensitive data)
                    const { data: nextEnigma } = await supabase
                        .from('enigmas')
                        .select('id, number, title, scheduled_at, published')
                        .eq('published', false)
                        .not('scheduled_at', 'is', null)
                        .order('scheduled_at', { ascending: true })
                        .limit(1)
                        .maybeSingle();

                    const timerDiv = document.getElementById('countdownTimer');

                    if (!nextEnigma) {
                        timerDiv.innerHTML = '<p>‚è≥ Aucune √©nigme programm√©e</p>';
                        return;
                    }

                    // Use Paris timezone
                    const now = new Date();
                    const target = toParisTime(nextEnigma.scheduled_at);
                    const diff = target - now;

                    if (diff <= 0) {
                        // Enigma should be published now
                        timerDiv.innerHTML = '<p>üöÄ Nouvelle √©nigme disponible !</p>';

                        // Auto-publish if not yet published
                        if (!nextEnigma.published) {
                            await supabase
                                .from('enigmas')
                                .update({ published: true })
                                .eq('id', nextEnigma.id);

                            // Reload enigmas if on that page
                            const enigmesSection = document.getElementById('enigmes-section');
                            if (enigmesSection && enigmesSection.classList.contains('active')) {
                                this.loadEnigmes();
                            }
                        }
                        return;
                    }

                    // Calculate time remaining
                    const days = Math.floor(diff / (1000 * 60 * 60 * 24));
                    const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
                    const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
                    const seconds = Math.floor((diff % (1000 * 60)) / 1000);

                    let timeString = '';
                    if (days > 0) timeString += `${days}j `;
                    timeString += `${hours}h ${minutes}m ${seconds}s`;

                    timerDiv.innerHTML = `
                        <p style="font-size: 1em; margin-bottom: 10px;">Prochaine √©nigme :</p>
                        <p style="font-size: 0.9em; opacity: 0.8; margin-bottom: 5px;">${nextEnigma.title}</p>
                        <h2>${timeString}</h2>
                    `;

                } catch (error) {
                    console.error('Error updating countdown:', error);
                }
            },

            // ========== ENIGMES ==========

            async loadEnigmes() {
                const container = document.getElementById('enigmesList');
                container.innerHTML = '<div class="loading">Chargement des √©nigmes...</div>';

                try {
                    // Get published enigmas (WITHOUT sensitive data)
                    const { data: enigmas } = await supabase
                        .from('enigmas')
                        .select('id, number, title, description, image_url, audio_url, location, validation_type, has_game, game_clues, published, scheduled_at, created_at')
                        .eq('published', true)
                        .order('number', { ascending: true });

                    if (!enigmas || enigmas.length === 0) {
                        container.innerHTML = '<p style="text-align: center; color: #666;">Aucune √©nigme disponible pour le moment.</p>';
                        return;
                    }

                    container.innerHTML = '';

                    // Track if previous enigma is solved (for sequential access)
                    let previousSolved = true; // First enigma is always accessible

                    for (const enigma of enigmas) {
                        // Get progress
                        const progress = await this.getProgress(enigma.id);
                        const lockStatus = this.isLocked(progress);

                        const enigmeDiv = document.createElement('div');
                        enigmeDiv.className = 'enigme-item';
                        if (progress && progress.solved) enigmeDiv.classList.add('solved');
                        if (lockStatus.locked) enigmeDiv.classList.add('locked');

                        let content = `<h3>√ânigme #${enigma.number} - ${enigma.title}</h3>`;

                        // Check if previous enigma is solved (sequential access)
                        if (!previousSolved && !this.currentUser?.is_admin && !this.currentUser?.is_test) {
                            content += `
                                <div class="alert alert-warning" style="text-align: center;">
                                    üîí <strong>√ânigme verrouill√©e</strong><br>
                                    Tu dois d'abord r√©soudre l'√©nigme pr√©c√©dente !
                                </div>
                            `;
                            enigmeDiv.innerHTML = content;
                            enigmeDiv.classList.add('locked');
                            container.appendChild(enigmeDiv);
                            // Don't update previousSolved - keep it false for next enigmas
                            continue;
                        }

                        // Show lock timer if locked (wrong attempts)
                        if (lockStatus.locked) {
                            content += `
                    <div class="lockout-timer">
                        <h3>üîí Bloqu√©</h3>
                        <p>Temps restant : ${lockStatus.remaining} minutes</p>
                    </div>
                `;
                        }

                        content += `<p>${enigma.description}</p>`;

                        // Show image if available
                        if (enigma.image_url) {
                            content += `<img src="${enigma.image_url}" class="enigme-image" alt="Image de l'√©nigme" onerror="this.style.display='none'" />`;
                        }

                        // Show audio player if available
                        if (enigma.audio_url) {
                            content += `
                                <div class="audio-player" style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); border: 1px solid #81FE0E; border-radius: 10px; padding: 12px 15px; margin: 15px 0; display: flex; align-items: center; gap: 12px;">
                                    <button onclick="hdnApp.toggleAudioPlayer(${enigma.id})" id="audio-btn-${enigma.id}" 
                                            style="background: #81FE0E; border: none; color: #000; width: 40px; height: 40px; border-radius: 50%; cursor: pointer; font-size: 16px; display: flex; align-items: center; justify-content: center; flex-shrink: 0;">
                                        ‚ñ∂Ô∏è
                                    </button>
                                    <div style="flex-grow: 1; width: 100%;">
                                        <div style="display: flex; align-items: center; gap: 8px;">
                                            <span style="color: #81FE0E; font-size: 12px;">üéµ</span>
                                            <span style="color: #fff; font-size: 13px;">Bouge ton corps</span>
                                            <span id="audio-time-${enigma.id}" style="color: #888; font-size: 11px; margin-left: auto;">0:00 / 0:00</span>
                                        </div>
                                        <div id="audio-timeline-${enigma.id}" 
                                             onmousedown="hdnApp.startDrag(event, ${enigma.id})"
                                             ontouchstart="hdnApp.startDrag(event, ${enigma.id})"
                                             style="background: #333; border-radius: 4px; height: 6px; margin-top: 8px; cursor: pointer; position: relative;">
                                            <div id="audio-progress-${enigma.id}" style="background: linear-gradient(90deg, #81FE0E, #4ade80); height: 100%; width: 0%; border-radius: 4px; pointer-events: none; position: relative;">
                                                <div id="audio-handle-${enigma.id}" style="position: absolute; right: -6px; top: 50%; transform: translateY(-50%); width: 14px; height: 14px; background: #fff; border-radius: 50%; box-shadow: 0 0 5px rgba(0,0,0,0.5); opacity: 0; transition: opacity 0.2s;"></div>
                                            </div>
                                        </div>
                                    </div>
                                    <div style="display: flex; align-items: center; gap: 6px;">
                                        <span id="audio-volume-icon-${enigma.id}" onclick="hdnApp.toggleMute(${enigma.id})" style="color: #81FE0E; font-size: 14px; cursor: pointer; width: 20px; text-align: center;">üîä</span>
                                        <div id="audio-volume-bar-${enigma.id}" 
                                             onmousedown="hdnApp.startVolumeDrag(event, ${enigma.id})"
                                             ontouchstart="hdnApp.startVolumeDrag(event, ${enigma.id})"
                                             style="background: #333; border-radius: 4px; height: 4px; width: 100px; cursor: pointer; position: relative;">
                                            <div id="audio-volume-progress-${enigma.id}" style="background: linear-gradient(90deg, #81FE0E, #4ade80); height: 100%; width: 70%; border-radius: 4px; pointer-events: none; position: relative;">
                                                <div id="audio-volume-handle-${enigma.id}" style="position: absolute; right: -5px; top: 50%; transform: translateY(-50%); width: 12px; height: 12px; background: #fff; border-radius: 50%; box-shadow: 0 0 5px rgba(0,0,0,0.5); opacity: 0; transition: opacity 0.2s;"></div>
                                            </div>
                                        </div>
                                    </div>
                                    <audio id="audio-element-${enigma.id}" src="${enigma.audio_url}" preload="metadata"
                                           ontimeupdate="hdnApp.updateAudioProgress(${enigma.id})"
                                           onloadedmetadata="hdnApp.onAudioLoaded(${enigma.id})"
                                           onended="hdnApp.onAudioEnded(${enigma.id})"></audio>
                                </div>
                            `;
                        }

                        // Answer form or solved status
                        if (progress && progress.solved) {
                            content += `<div class="alert alert-success">‚úÖ √ânigme r√©solue !</div>`;

                            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                            // √âTAPE JEU - Si l'√©nigme a un jeu et qu'il n'est pas compl√©t√©
                            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                            if (enigma.has_game && !progress.game_completed_at) {
                                // Jeu non compl√©t√© - afficher l'√©cran de lancement
                                content += `
                                    <div style="background: linear-gradient(135deg, #000000, #1a1a2e); border: 2px solid #81FE0E; border-radius: 15px; padding: 25px; margin: 15px 0; text-align: center;">
                                        <h3 style="color: #81FE0E; margin: 0 0 15px 0; font-size: 1.4em;">üéÆ √âpreuve Finale</h3>
                                        <p style="color: white; margin: 0 0 20px 0;">
                                            Avant de chercher le QR Code, tu dois compl√©ter le jeu de plateforme !<br>
                                            <span style="color: #81FE0E;">Plus tu es rapide, plus tu gagnes de points bonus.</span>
                                        </p>
                                        <div style="background: rgba(129, 254, 14, 0.1); border-radius: 10px; padding: 15px; margin: 15px 0;">
                                            <p style="color: #81FE0E; margin: 0; font-weight: bold;">üèÜ Bonus temps :</p>
                                            <p style="color: white; margin: 5px 0 0 0; font-size: 0.9em;">
                                                < 30 min : +200 pts | < 45 min : +100 pts | < 1h : +50 pts
                                            </p>
                                        </div>
                                        <div class="game-buttons-desktop">
                                            ${progress.game_started_at ? `
                                                <button class="btn btn-success" style="font-size: 1.2em; padding: 15px 40px;" onclick="hdnApp.resumeGame(${enigma.id})">
                                                    ‚ñ∂Ô∏è Reprendre le jeu
                                                </button>
                                            ` : `
                                                <button class="btn btn-success" style="font-size: 1.2em; padding: 15px 40px;" onclick="hdnApp.startGame(${enigma.id})">
                                                    üöÄ Lancer le jeu !
                                                </button>
                                            `}
                                        </div>
                                        <p class="game-mobile-warning" style="color: #ff9800; margin: 15px 0 0 0; font-size: 0.95em; display: none;">
                                            üíª Le jeu n√©cessite un ordinateur. Ouvre cette page sur un PC pour jouer !
                                        </p>
                                        <p class="game-desktop-warning" style="color: #888; margin: 15px 0 0 0; font-size: 0.8em;">
                                            ‚ö†Ô∏è Le jeu n√©cessite un ordinateur (pas de mobile)
                                        </p>
                                    </div>
                                `;
                            } else {
                                // Afficher le score du jeu si compl√©t√©
                                if (enigma.has_game && progress.game_completed_at) {
                                    content += `
                                        <div class="alert alert-success" style="background: linear-gradient(135deg, #000, #1a1a2e); border: 2px solid #81FE0E;">
                                            <span style="color: #81FE0E;">üéÆ √âpreuve Finale compl√©t√©e !</span><br>
                                            <span style="color: white;">+${progress.game_score || 0} points bonus</span>
                                        </div>
                                    `;
                                }

                                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                                // √âTAPE QR CODE - Flow normal
                                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

                                // D√©terminer si on affiche les indices du jeu ou l'emplacement classique
                                const hasGameClues = enigma.has_game && progress.game_completed_at && enigma.game_clues && enigma.game_clues.length > 0;

                                // G√©n√©rer le HTML pour les indices du jeu
                                const gameCluesHTML = hasGameClues ? `
                                    <div style="background: linear-gradient(135deg, #000, #1a1a2e); border: 2px solid #81FE0E; border-radius: 12px; padding: 20px; margin: 15px 0;">
                                        <h4 style="color: #81FE0E; margin: 0 0 15px 0; text-align: center;">üîç Tes indices pour trouver le QR Code</h4>
                                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                                            ${enigma.game_clues.map(clue => `
                                                <div style="background: #343973; color: white; padding: 12px; border-radius: 8px; text-align: center; font-weight: bold;">
                                                    ${typeof clue === 'object' ? clue.text : clue}
                                                </div>
                                            `).join('')}
                                        </div>
                                    </div>
                                ` : '';

                                // HTML pour l'emplacement classique
                                const locationHTML = !hasGameClues && enigma.location ?
                                    `<div class="alert alert-info">üìç <strong>Emplacement du QR Code :</strong> ${enigma.location}</div>` : '';

                                if (enigma.location || hasGameClues) {
                                    if (progress.qr_scanned) {
                                        // Already scanned
                                        content += `<div class="alert alert-success">‚úÖ QR Code scann√© ! +${progress.points_earned || 0} points</div>`;
                                        content += hasGameClues ? gameCluesHTML : `<div class="alert alert-info">üìç <strong>Emplacement :</strong> ${enigma.location}</div>`;
                                    } else if (progress.qr_hunt_started_at) {
                                        // Hunt started - show location/clues + timer + scanner
                                        const huntStarted = new Date(progress.qr_hunt_started_at);
                                        const now = new Date();
                                        const elapsedMs = now - huntStarted;
                                        const elapsedMin = Math.floor(elapsedMs / 60000);
                                        const elapsedSec = Math.floor((elapsedMs % 60000) / 1000);

                                        // Calculate current bonus
                                        let currentBonus = 0;
                                        let bonusText = '';
                                        if (elapsedMin < 20) {
                                            currentBonus = 20;
                                            bonusText = 'üî• +20 pts';
                                        } else if (elapsedMin < 40) {
                                            currentBonus = 10;
                                            bonusText = '‚ö° +10 pts';
                                        } else if (elapsedMin < 60) {
                                            currentBonus = 5;
                                            bonusText = '‚ú® +5 pts';
                                        } else {
                                            bonusText = '‚è∞ Pas de bonus';
                                        }

                                        content += `
                                            ${hasGameClues ? gameCluesHTML : `<div class="alert alert-info">üìç <strong>Emplacement du QR Code :</strong> ${enigma.location}</div>`}
                                            <div style="background: #f0f9ff; border: 2px solid #343973; border-radius: 10px; padding: 15px; margin: 15px 0; text-align: center;">
                                                <p style="margin: 0 0 10px 0; font-size: 1.1em;">‚è±Ô∏è Temps √©coul√© : <strong id="qrTimer-${enigma.id}">${elapsedMin}:${elapsedSec.toString().padStart(2, '0')}</strong></p>
                                                <p style="margin: 0; font-size: 1.2em; color: ${currentBonus > 0 ? '#81FE0E' : '#ff4444'};">Bonus actuel : <strong id="qrBonus-${enigma.id}">${bonusText}</strong></p>
                                            </div>
                                            <button class="btn btn-primary" style="width: 100%;" onclick="hdnApp.openQRScanner(${enigma.id})">üì± Scanner le QR Code</button>
                                        `;

                                        // Start live timer update
                                        this.startQRTimer(enigma.id, huntStarted);
                                    } else {
                                        // Need to click "Je suis pr√™t" - OR old system (backward compatible)
                                        if (progress.solved_at && !progress.hasOwnProperty('qr_hunt_started_at')) {
                                            // Old system - show scanner directly for backward compatibility
                                            content += hasGameClues ? gameCluesHTML : `<div class="alert alert-info">üìç <strong>Emplacement du QR Code :</strong> ${enigma.location}</div>`;
                                            content += `<div class="alert alert-warning">‚ö†Ô∏è Scanne le QR code pour gagner tes points !</div>`;
                                            content += `<button class="btn btn-primary" onclick="hdnApp.openQRScanner(${enigma.id})">üì± Scanner le QR Code</button>`;
                                        } else {
                                            // New system - show "Je suis pr√™t" button
                                            content += `
                                                <div style="background: linear-gradient(135deg, #343973, #4a5193); border-radius: 10px; padding: 20px; margin: 15px 0; text-align: center;">
                                                    <button class="btn btn-success" style="font-size: 1.2em; padding: 15px 30px;" onclick="hdnApp.startQRHunt(${enigma.id})">
                                                        üèÉ Je suis pr√™t √† chercher le QR Code !
                                                    </button>
                                                    <p style="color: white; margin: 15px 0 0 0; font-size: 0.9em;">
                                                        ‚ö†Ô∏è Attention : le chrono bonus d√©marre d√®s que tu appuies !
                                                    </p>
                                                </div>
                                            `;
                                        }
                                    }
                                }
                            }
                        } else if (!lockStatus.locked) {
                            // Fetch hints securely via RPC
                            const { data: hintsData } = await supabase.rpc('get_enigma_hints', {
                                p_enigma_id: enigma.id,
                                p_player_id: this.currentUser.team_id ? null : this.currentUser.id,
                                p_team_id: this.currentUser.team_id || null
                            });

                            // Hints section - Only show if NOT solved and hints exist
                            if (hintsData && (hintsData.hint1_exists || hintsData.hint2_exists || hintsData.hint3_exists)) {
                                content += '<div class="hints-section"><h4>üí° Indices</h4>';

                                if (hintsData.hint1_exists) {
                                    content += `<div class="hint-item">`;
                                    content += hintsData.hint1_unlocked
                                        ? `<p><strong>Indice 1 :</strong> ${hintsData.hint1_content}</p>`
                                        : `<button class="btn btn-warning" onclick="hdnApp.requestHint(${enigma.id}, 1)">üîì Indice 1 (-5 points)</button>`;
                                    content += '</div>';
                                }

                                if (hintsData.hint2_exists) {
                                    content += `<div class="hint-item ${!hintsData.hint1_unlocked ? 'locked' : ''}">`;
                                    content += hintsData.hint2_unlocked
                                        ? `<p><strong>Indice 2 :</strong> ${hintsData.hint2_content}</p>`
                                        : `<button class="btn btn-warning" onclick="hdnApp.requestHint(${enigma.id}, 2)" ${!hintsData.hint1_unlocked ? 'disabled' : ''}>üîì Indice 2 (-10 points)</button>`;
                                    content += '</div>';
                                }

                                if (hintsData.hint3_exists) {
                                    content += `<div class="hint-item ${!hintsData.hint2_unlocked ? 'locked' : ''}">`;
                                    content += hintsData.hint3_unlocked
                                        ? `<p><strong>Indice 3 :</strong> ${hintsData.hint3_content}</p>`
                                        : `<button class="btn btn-warning" onclick="hdnApp.requestHint(${enigma.id}, 3)" ${!hintsData.hint2_unlocked ? 'disabled' : ''}>üîì Indice 3 (-15 points)</button>`;
                                    content += '</div>';
                                }

                                // Bouton "J'abandonne" - toujours visible
                                content += `
                                    <div class="hint-item" style="margin-top: 15px; border-top: 1px dashed #ccc; padding-top: 15px;">
                                        <button class="btn btn-danger" onclick="hdnApp.giveUp(${enigma.id})" style="width: 100%;">
                                            üè≥Ô∏è J'abandonne, donne-moi la solution (-50 points)
                                        </button>
                                    </div>
                                `;

                                content += '</div>';
                            }

                            // Check for pending submission - Fixed query
                            let submissionQuery = supabase
                                .from('submissions')
                                .select('*')
                                .eq('enigma_id', enigma.id)
                                .eq('status', 'pending');

                            if (this.currentUser.team_id) {
                                submissionQuery = submissionQuery.eq('team_id', this.currentUser.team_id);
                            } else {
                                submissionQuery = submissionQuery.eq('player_id', this.currentUser.id);
                            }

                            const { data: pendingSubmission } = await submissionQuery.maybeSingle();

                            if (pendingSubmission) {
                                // Show pending validation message
                                content += `
                        <div class="alert alert-info" style="background: #fff3cd; border-left: 4px solid #ffaa00; padding: 15px; margin-top: 15px;">
                            <h4 style="color: #856404; margin: 0 0 10px 0;">‚è≥ En attente de validation par HDN</h4>
                            <p style="color: #856404; margin: 0;">
                                <strong>Ta r√©ponse :</strong> ${pendingSubmission.answer}<br>
                                Ton admin va valider ta r√©ponse bient√¥t !
                            </p>
                        </div>
                    `;
                            } else {
                                // Show answer form
                                content += `
                        <div style="margin-top: 15px;">
                            <label>Ta r√©ponse :</label>
                            <input type="text" id="answer-${enigma.id}" placeholder="Ta r√©ponse..." />
                            <button class="btn btn-success" style="width: 100%; margin-top: 10px;" 
                                    onclick="hdnApp.submitAnswer(${enigma.id})">
                                ‚úÖ Valider
                            </button>
                            <p style="font-size: 0.85em; color: #666; margin-top: 5px;">
                                Tentatives restantes : ${3 - (progress?.wrong_attempts || 0)}
                            </p>
                        </div>
                    `;
                            }
                        }

                        enigmeDiv.innerHTML = content;
                        container.appendChild(enigmeDiv);

                        // Update previousSolved for next iteration (sequential access)
                        previousSolved = progress && progress.solved;
                    }

                } catch (error) {
                    console.error('Error loading enigmas:', error);
                    container.innerHTML = '<p style="color: #ff4444;">Erreur lors du chargement des √©nigmes.</p>';
                }
            },

            async getProgress(enigmaId) {
                try {
                    console.log('getProgress called for enigmaId:', enigmaId, 'user:', this.currentUser?.id, 'team:', this.currentUser?.team_id);

                    let query = supabase
                        .from('enigma_progress')
                        .select('*')
                        .eq('enigma_id', enigmaId);

                    if (this.currentUser.team_id) {
                        query = query.eq('team_id', this.currentUser.team_id);
                    } else {
                        query = query.eq('player_id', this.currentUser.id);
                    }

                    // Use limit(1) + order to handle duplicates gracefully
                    const { data: existingList, error: selectError } = await query
                        .order('created_at', { ascending: true })
                        .limit(1);

                    const existing = existingList && existingList.length > 0 ? existingList[0] : null;

                    console.log('getProgress existing:', existing, 'error:', selectError);

                    if (existing) {
                        return existing;
                    }

                    // Create new progress
                    console.log('Creating new progress...');
                    const { data: newProgress, error: insertError } = await supabase
                        .from('enigma_progress')
                        .insert([{
                            player_id: this.currentUser.team_id ? null : this.currentUser.id,
                            team_id: this.currentUser.team_id || null,
                            enigma_id: enigmaId,
                            wrong_attempts: 0,
                            hints_used: [],
                            lockout_count: 0,
                            qr_scanned: false,
                            solved: false,
                            points_earned: 0,
                            started_at: new Date().toISOString()
                        }])
                        .select()
                        .single();

                    console.log('getProgress newProgress:', newProgress, 'error:', insertError);

                    if (insertError) {
                        console.error('Error creating progress:', insertError);
                        return null;
                    }

                    return newProgress;
                } catch (error) {
                    console.error('Error getting progress:', error);
                    return null;
                }
            },

            isLocked(progress) {
                if (!progress || !progress.locked_until) return { locked: false };

                const now = new Date();
                const lockEnd = new Date(progress.locked_until);

                if (now < lockEnd) {
                    const remaining = Math.ceil((lockEnd - now) / 1000 / 60);
                    return {
                        locked: true,
                        remaining: remaining
                    };
                }

                return { locked: false };
            },

            async updateProgress(progressId, updates) {
                console.log('updateProgress called with:', { progressId, updates });

                if (!progressId) {
                    console.error('updateProgress: progressId is null/undefined');
                    throw new Error('Progress ID is missing');
                }

                const { data, error } = await supabase
                    .from('enigma_progress')
                    .update({
                        ...updates,
                        updated_at: new Date().toISOString()
                    })
                    .eq('id', progressId)
                    .select();

                console.log('updateProgress result:', { data, error });

                if (error) throw error;
                return data;
            },

            async requestHint(enigmaId, hintNumber) {
                try {
                    // Use secure RPC to unlock hint
                    const { data: result, error } = await supabase.rpc('unlock_hint', {
                        p_enigma_id: enigmaId,
                        p_hint_number: hintNumber,
                        p_player_id: this.currentUser.team_id ? null : this.currentUser.id,
                        p_team_id: this.currentUser.team_id || null
                    });

                    if (error) throw error;

                    if (!result.success) {
                        showToast(`‚ùå ${result.error}`, 'error');
                        return;
                    }

                    showToast(`‚úÖ Indice d√©bloqu√© ! (-${result.cost} points)`, 'success');

                    // Reload
                    await this.loadUserData();
                    await this.loadEnigmes();

                } catch (error) {
                    console.error('Error:', error);
                    showToast('‚ùå Erreur lors de la demande d\'indice', 'error');
                }
            },

            // ========== AUDIO PLAYER CONTROLS ==========
            audioPlaying: {},

            toggleAudioPlayer(enigmaId) {
                const audio = document.getElementById(`audio-element-${enigmaId}`);
                const btn = document.getElementById(`audio-btn-${enigmaId}`);

                if (!audio) return;

                if (audio.paused) {
                    // Stop other playing audios
                    Object.keys(this.audioPlaying).forEach(id => {
                        if (id != enigmaId && this.audioPlaying[id]) {
                            const otherAudio = document.getElementById(`audio-element-${id}`);
                            const otherBtn = document.getElementById(`audio-btn-${id}`);
                            if (otherAudio) otherAudio.pause();
                            if (otherBtn) otherBtn.textContent = '‚ñ∂Ô∏è';
                            this.audioPlaying[id] = false;
                        }
                    });

                    audio.play();
                    btn.textContent = '‚è∏Ô∏è';
                    this.audioPlaying[enigmaId] = true;
                } else {
                    audio.pause();
                    btn.textContent = '‚ñ∂Ô∏è';
                    this.audioPlaying[enigmaId] = false;
                }
            },

            // Volume state
            audioVolumes: {}, // Store volume per enigma
            volumeBeforeMute: {}, // Store volume before mute
            isVolumeDragging: false,
            volumeDragEnigmaId: null,
            boundOnVolumeDrag: null,
            boundEndVolumeDrag: null,

            setAudioVolume(enigmaId, value) {
                const audio = document.getElementById(`audio-element-${enigmaId}`);
                const progressBar = document.getElementById(`audio-volume-progress-${enigmaId}`);
                const icon = document.getElementById(`audio-volume-icon-${enigmaId}`);

                if (audio) {
                    audio.volume = value / 100;
                    this.audioVolumes[enigmaId] = value;
                }
                if (progressBar) {
                    progressBar.style.width = value + '%';
                }
                if (icon) {
                    if (value === 0) icon.textContent = 'üîá';
                    else if (value < 30) icon.textContent = 'üîà';
                    else if (value < 70) icon.textContent = 'üîâ';
                    else icon.textContent = 'üîä';
                }
            },

            toggleMute(enigmaId) {
                const currentVolume = this.audioVolumes[enigmaId] ?? 70;

                if (currentVolume > 0) {
                    this.volumeBeforeMute[enigmaId] = currentVolume;
                    this.setAudioVolume(enigmaId, 0);
                } else {
                    const restoreVolume = this.volumeBeforeMute[enigmaId] ?? 70;
                    this.setAudioVolume(enigmaId, restoreVolume);
                }
            },

            startVolumeDrag(event, enigmaId) {
                event.preventDefault();
                this.isVolumeDragging = true;
                this.volumeDragEnigmaId = enigmaId;

                const handle = document.getElementById(`audio-volume-handle-${enigmaId}`);
                if (handle) handle.style.opacity = '1';

                this.updateVolumeDragPosition(event, enigmaId);

                // Bind if not already
                if (!this.boundOnVolumeDrag) {
                    this.boundOnVolumeDrag = this.onVolumeDrag.bind(this);
                    this.boundEndVolumeDrag = this.endVolumeDrag.bind(this);
                }

                document.addEventListener('mousemove', this.boundOnVolumeDrag);
                document.addEventListener('mouseup', this.boundEndVolumeDrag);
                document.addEventListener('touchmove', this.boundOnVolumeDrag, { passive: false });
                document.addEventListener('touchend', this.boundEndVolumeDrag);
            },

            onVolumeDrag(event) {
                if (!this.isVolumeDragging || !this.volumeDragEnigmaId) return;
                event.preventDefault();
                this.updateVolumeDragPosition(event, this.volumeDragEnigmaId);
            },

            endVolumeDrag(event) {
                if (!this.isVolumeDragging) return;

                const handle = document.getElementById(`audio-volume-handle-${this.volumeDragEnigmaId}`);
                const bar = document.getElementById(`audio-volume-bar-${this.volumeDragEnigmaId}`);

                if (handle && bar) {
                    const rect = bar.getBoundingClientRect();
                    const clientX = event.clientX || (event.changedTouches && event.changedTouches[0].clientX);
                    const clientY = event.clientY || (event.changedTouches && event.changedTouches[0].clientY);

                    if (clientX < rect.left - 10 || clientX > rect.right + 10 || clientY < rect.top - 10 || clientY > rect.bottom + 10) {
                        handle.style.opacity = '0';
                    }
                }

                this.isVolumeDragging = false;
                this.volumeDragEnigmaId = null;

                document.removeEventListener('mousemove', this.boundOnVolumeDrag);
                document.removeEventListener('mouseup', this.boundEndVolumeDrag);
                document.removeEventListener('touchmove', this.boundOnVolumeDrag);
                document.removeEventListener('touchend', this.boundEndVolumeDrag);
            },

            updateVolumeDragPosition(event, enigmaId) {
                const bar = document.getElementById(`audio-volume-bar-${enigmaId}`);
                if (!bar) return;

                const rect = bar.getBoundingClientRect();
                const clientX = event.clientX || (event.touches && event.touches[0].clientX);
                let posX = clientX - rect.left;

                posX = Math.max(0, Math.min(posX, rect.width));
                const percentage = Math.round((posX / rect.width) * 100);

                this.setAudioVolume(enigmaId, percentage);
            },

            updateAudioProgress(enigmaId) {
                const audio = document.getElementById(`audio-element-${enigmaId}`);
                const progressBar = document.getElementById(`audio-progress-${enigmaId}`);
                const timeDisplay = document.getElementById(`audio-time-${enigmaId}`);

                if (!audio || !progressBar) return;

                const progress = (audio.currentTime / audio.duration) * 100;
                progressBar.style.width = progress + '%';

                if (timeDisplay) {
                    const currentMins = Math.floor(audio.currentTime / 60);
                    const currentSecs = Math.floor(audio.currentTime % 60);
                    const totalMins = Math.floor(audio.duration / 60) || 0;
                    const totalSecs = Math.floor(audio.duration % 60) || 0;
                    timeDisplay.textContent = `${currentMins}:${currentSecs.toString().padStart(2, '0')} / ${totalMins}:${totalSecs.toString().padStart(2, '0')}`;
                }
            },

            onAudioLoaded(enigmaId) {
                const audio = document.getElementById(`audio-element-${enigmaId}`);
                const timeDisplay = document.getElementById(`audio-time-${enigmaId}`);
                const timeline = document.getElementById(`audio-timeline-${enigmaId}`);
                const handle = document.getElementById(`audio-handle-${enigmaId}`);

                if (audio && timeDisplay) {
                    const totalMins = Math.floor(audio.duration / 60);
                    const totalSecs = Math.floor(audio.duration % 60);
                    timeDisplay.textContent = `0:00 / ${totalMins}:${totalSecs.toString().padStart(2, '0')}`;
                }

                // Show handle on hover - Timeline
                if (timeline && handle) {
                    timeline.addEventListener('mouseenter', () => handle.style.opacity = '1');
                    timeline.addEventListener('mouseleave', () => {
                        if (!this.isDragging) handle.style.opacity = '0';
                    });
                }

                // Show handle on hover - Volume bar
                const volumeBar = document.getElementById(`audio-volume-bar-${enigmaId}`);
                const volumeHandle = document.getElementById(`audio-volume-handle-${enigmaId}`);
                if (volumeBar && volumeHandle) {
                    volumeBar.addEventListener('mouseenter', () => volumeHandle.style.opacity = '1');
                    volumeBar.addEventListener('mouseleave', () => {
                        if (!this.isVolumeDragging) volumeHandle.style.opacity = '0';
                    });
                }

                // Initialize volume
                this.audioVolumes[enigmaId] = 70;
                if (audio) audio.volume = 0.7;
            },

            // Drag state
            isDragging: false,
            dragEnigmaId: null,

            startDrag(event, enigmaId) {
                event.preventDefault();
                this.isDragging = true;
                this.dragEnigmaId = enigmaId;

                const handle = document.getElementById(`audio-handle-${enigmaId}`);
                if (handle) handle.style.opacity = '1';

                // Set initial position
                this.updateDragPosition(event, enigmaId);

                // Add listeners
                document.addEventListener('mousemove', this.boundOnDrag);
                document.addEventListener('mouseup', this.boundEndDrag);
                document.addEventListener('touchmove', this.boundOnDrag, { passive: false });
                document.addEventListener('touchend', this.boundEndDrag);
            },

            onDrag(event) {
                if (!this.isDragging || !this.dragEnigmaId) return;
                event.preventDefault();
                this.updateDragPosition(event, this.dragEnigmaId);
            },

            endDrag(event) {
                if (!this.isDragging) return;

                const enigmaId = this.dragEnigmaId;
                const handle = document.getElementById(`audio-handle-${enigmaId}`);
                const timeline = document.getElementById(`audio-timeline-${enigmaId}`);

                // Hide handle if not hovering
                if (handle && timeline) {
                    const rect = timeline.getBoundingClientRect();
                    const clientX = event.clientX || (event.changedTouches && event.changedTouches[0].clientX);
                    const clientY = event.clientY || (event.changedTouches && event.changedTouches[0].clientY);

                    if (clientX < rect.left || clientX > rect.right || clientY < rect.top - 10 || clientY > rect.bottom + 10) {
                        handle.style.opacity = '0';
                    }
                }

                this.isDragging = false;
                this.dragEnigmaId = null;

                // Remove listeners
                document.removeEventListener('mousemove', this.boundOnDrag);
                document.removeEventListener('mouseup', this.boundEndDrag);
                document.removeEventListener('touchmove', this.boundOnDrag);
                document.removeEventListener('touchend', this.boundEndDrag);
            },

            updateDragPosition(event, enigmaId) {
                const audio = document.getElementById(`audio-element-${enigmaId}`);
                const timeline = document.getElementById(`audio-timeline-${enigmaId}`);
                const progressBar = document.getElementById(`audio-progress-${enigmaId}`);

                if (!audio || !timeline || !audio.duration) return;

                const rect = timeline.getBoundingClientRect();
                const clientX = event.clientX || (event.touches && event.touches[0].clientX);
                let posX = clientX - rect.left;

                // Clamp to timeline bounds
                posX = Math.max(0, Math.min(posX, rect.width));

                const percentage = posX / rect.width;
                audio.currentTime = percentage * audio.duration;

                // Update visual immediately
                if (progressBar) {
                    progressBar.style.width = (percentage * 100) + '%';
                }
                this.updateAudioProgress(enigmaId);
            },

            onAudioEnded(enigmaId) {
                const btn = document.getElementById(`audio-btn-${enigmaId}`);
                if (btn) btn.textContent = '‚ñ∂Ô∏è';
                this.audioPlaying[enigmaId] = false;
            },

            async giveUp(enigmaId) {
                // Confirmation
                if (!confirm('‚ö†Ô∏è Tu vas perdre 50 points et voir la solution.\n\nL\'√©nigme sera valid√©e et tu pourras passer √† la suivante.\n\nConfirmer ?')) {
                    return;
                }

                try {
                    const progress = await this.getProgress(enigmaId);
                    const GIVE_UP_COST = 50;

                    // Deduct points from player
                    const newPoints = this.currentUser.points - GIVE_UP_COST;
                    await supabase
                        .from('players')
                        .update({ points: newPoints })
                        .eq('id', this.currentUser.id);

                    // Deduct from team if applicable
                    if (this.currentUser.team_id) {
                        const { data: team } = await supabase
                            .from('teams')
                            .select('points')
                            .eq('id', this.currentUser.team_id)
                            .maybeSingle();

                        if (team) {
                            await supabase
                                .from('teams')
                                .update({ points: team.points - GIVE_UP_COST })
                                .eq('id', this.currentUser.team_id);

                            // Update all team members' points
                            const { data: teamMembers } = await supabase
                                .from('players')
                                .select('id, points')
                                .eq('team_id', this.currentUser.team_id);

                            if (teamMembers) {
                                for (const member of teamMembers) {
                                    await supabase
                                        .from('players')
                                        .update({ points: member.points - GIVE_UP_COST })
                                        .eq('id', member.id);
                                }
                            }
                        }
                    }

                    // Mark as solved with 0 points (gave up)
                    await this.updateProgress(progress.id, {
                        solved: true,
                        solved_at: new Date().toISOString(),
                        points_earned: -GIVE_UP_COST, // Negative to track gave up
                        gave_up: true
                    });

                    // Get the answer to display
                    const { data: answerResult } = await supabase
                        .rpc('get_enigma_answer', { p_enigma_id: enigmaId });

                    // Show solution in a modal
                    const modal = document.createElement('div');
                    modal.id = 'solutionModal';
                    modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 10000; display: flex; align-items: center; justify-content: center; padding: 20px;';
                    modal.innerHTML = `
                        <div style="background: white; padding: 30px; border-radius: 15px; max-width: 400px; width: 100%; text-align: center;">
                            <h3 style="color: #343973; margin-bottom: 20px;">üè≥Ô∏è Solution r√©v√©l√©e</h3>
                            <p style="color: #666; margin-bottom: 15px;">La r√©ponse √©tait :</p>
                            <p style="font-size: 1.5em; color: #81FE0E; background: #343973; padding: 15px; border-radius: 10px; margin-bottom: 20px;">
                                <strong>${answerResult || 'Non disponible'}</strong>
                            </p>
                            <p style="color: #ff4444; margin-bottom: 20px;">-${GIVE_UP_COST} points</p>
                            <button class="btn btn-primary" onclick="document.getElementById('solutionModal').remove(); hdnApp.loadEnigmes(); hdnApp.loadUserData();">
                                OK, continuer
                            </button>
                        </div>
                    `;
                    document.body.appendChild(modal);

                    showToast(`üè≥Ô∏è Solution r√©v√©l√©e ! (-${GIVE_UP_COST} points)`, 'warning');

                } catch (error) {
                    console.error('Error:', error);
                    showToast('‚ùå Erreur lors de l\'abandon', 'error');
                }
            },

            async submitAnswer(enigmaId) {
                const answer = document.getElementById(`answer-${enigmaId}`).value.trim();

                if (!answer) {
                    showToast('‚ùå Entre une r√©ponse !', 'error');
                    return;
                }

                try {
                    const progress = await this.getProgress(enigmaId);

                    // Check if locked
                    const lockStatus = this.isLocked(progress);
                    if (lockStatus.locked) {
                        showToast(`üîí Tu es bloqu√© encore ${lockStatus.remaining} minutes`, 'error');
                        return;
                    }

                    // Get enigma info (WITHOUT answer and qr_secret)
                    const { data: enigma } = await supabase
                        .from('enigmas')
                        .select('id, number, title, validation_type')
                        .eq('id', enigmaId)
                        .single();

                    // Use RPC to validate answer securely (answer never leaves server)
                    const { data: validationResult, error: rpcError } = await supabase
                        .rpc('validate_enigma_answer', {
                            p_enigma_id: enigmaId,
                            p_answer: answer.toLowerCase().trim()
                        });

                    if (rpcError) throw rpcError;
                    const isCorrect = validationResult;

                    if (enigma.validation_type === 'manual') {
                        // Check if already submitted
                        let submissionQuery = supabase
                            .from('submissions')
                            .select('id')
                            .eq('enigma_id', enigmaId)
                            .eq('status', 'pending');

                        if (this.currentUser.team_id) {
                            submissionQuery = submissionQuery.eq('team_id', this.currentUser.team_id);
                        } else {
                            submissionQuery = submissionQuery.eq('player_id', this.currentUser.id);
                        }

                        const { data: existingSubmission } = await submissionQuery.maybeSingle();

                        if (existingSubmission) {
                            showToast('‚è≥ Tu as d√©j√† une r√©ponse en attente de validation !', 'warning');
                            return;
                        }

                        // Make sure progress exists before submission
                        if (!progress) {
                            showToast('‚ùå Erreur : progression non trouv√©e', 'error');
                            return;
                        }

                        // Create submission for manual validation
                        const { error } = await supabase
                            .from('submissions')
                            .insert([{
                                enigma_id: enigmaId,
                                player_id: this.currentUser.id,
                                team_id: this.currentUser.team_id || null,
                                answer: answer,
                                status: 'pending'
                            }]);

                        if (error) throw error;

                        showToast('‚úÖ R√©ponse soumise ! En attente de validation par HDN...', 'info');
                        await this.loadEnigmes();

                    } else {
                        // Auto validation
                        if (isCorrect) {
                            // Check if progress exists
                            if (!progress || !progress.id) {
                                console.error('Progress is null or has no ID:', progress);
                                showToast('‚ùå Erreur : progression non trouv√©e', 'error');
                                return;
                            }

                            // Anti-IA detection: correct answer in less than 10 minutes
                            const progressCreated = new Date(progress.started_at || progress.created_at);
                            const now = new Date();
                            const elapsedMin = (now - progressCreated) / 60000;

                            let antiIaPenalty = false;
                            if (elapsedMin < 10 && !this.currentUser.is_admin && !this.currentUser.is_test) {
                                antiIaPenalty = true;

                                // Block access to all enigmas for 10 minutes
                                const blockUntil = new Date();
                                blockUntil.setMinutes(blockUntil.getMinutes() + 10);

                                if (this.currentUser.team_id) {
                                    // Block ALL team members
                                    await supabase
                                        .from('players')
                                        .update({ enigmas_blocked_until: blockUntil.toISOString() })
                                        .eq('team_id', this.currentUser.team_id);

                                    // Deduct 10 points from team
                                    const { data: team } = await supabase
                                        .from('teams')
                                        .select('points')
                                        .eq('id', this.currentUser.team_id)
                                        .maybeSingle();

                                    if (team) {
                                        await supabase
                                            .from('teams')
                                            .update({ points: team.points - 10 })
                                            .eq('id', this.currentUser.team_id);
                                    }

                                    // Update points for all team members too
                                    const { data: teamMembers } = await supabase
                                        .from('players')
                                        .select('id, points')
                                        .eq('team_id', this.currentUser.team_id);

                                    if (teamMembers) {
                                        for (const member of teamMembers) {
                                            await supabase
                                                .from('players')
                                                .update({ points: member.points - 10 })
                                                .eq('id', member.id);
                                        }
                                    }
                                } else {
                                    // Solo player - just block this player
                                    await supabase
                                        .from('players')
                                        .update({ enigmas_blocked_until: blockUntil.toISOString() })
                                        .eq('id', this.currentUser.id);

                                    // Deduct 10 points
                                    const newPoints = this.currentUser.points - 10;
                                    await supabase
                                        .from('players')
                                        .update({ points: newPoints })
                                        .eq('id', this.currentUser.id);
                                }
                            }

                            // Mark as solved (even with penalty)
                            await this.updateProgress(progress.id, {
                                solved: true,
                                solved_at: new Date().toISOString(),
                                points_earned: 0 // Will be calculated at QR scan
                            });

                            if (antiIaPenalty) {
                                // Redirect to home with penalty message
                                await this.loadUserData();
                                this.showSection('home');
                                showToast(`ü§ñ Demander les r√©ponses ne te donnera pas de m√©rite √† √™tre premier !\n\n-10 points\nüîí √ânigmes bloqu√©es 10 min\n\n(L'√©nigme est quand m√™me valid√©e)`, 'warning');
                            } else {
                                showToast(`üéâ Bonne r√©ponse !`, 'success');
                                await this.loadEnigmes();
                                await this.loadUserData();
                            }

                        } else {
                            // Wrong answer
                            const newAttempts = progress.wrong_attempts + 1;

                            if (newAttempts >= 3) {
                                // Lockout after 3 wrong attempts
                                const lockUntil = new Date();
                                lockUntil.setMinutes(lockUntil.getMinutes() + 15);

                                await this.updateProgress(progress.id, {
                                    wrong_attempts: newAttempts,
                                    locked_until: lockUntil.toISOString(),
                                    lockout_count: progress.lockout_count + 1
                                });

                                showToast('‚ùå Mauvaise r√©ponse ! √ânigme bloqu√©e pour 15 minutes.', 'error');
                            } else {
                                await this.updateProgress(progress.id, {
                                    wrong_attempts: newAttempts
                                });

                                showToast(`‚ùå Mauvaise r√©ponse ! (${3 - newAttempts} essais restants)`, 'error');
                            }

                            await this.loadEnigmes();
                        }
                    }

                } catch (error) {
                    console.error('Error:', error);
                    showToast('‚ùå Erreur lors de la soumission : ' + error.message, 'error');
                }
            },

            async awardPoints(points) {
                try {
                    // Update player points
                    const newPoints = this.currentUser.points + points;
                    await supabase
                        .from('players')
                        .update({ points: newPoints })
                        .eq('id', this.currentUser.id);

                    // Update team points if applicable
                    if (this.currentUser.team_id) {
                        const { data: team } = await supabase
                            .from('teams')
                            .select('points')
                            .eq('id', this.currentUser.team_id)
                            .maybeSingle();

                        if (team) {
                            await supabase
                                .from('teams')
                                .update({ points: team.points + points })
                                .eq('id', this.currentUser.team_id);
                        }
                    }
                } catch (error) {
                    console.error('Error awarding points:', error);
                }
            },

            // ========== QR SCANNER ==========

            async openQRScanner(enigmaId) {
                try {
                    // Get enigma info WITHOUT qr_secret
                    const { data: enigma } = await supabase
                        .from('enigmas')
                        .select('id, number, title, location, has_game, game_clues')
                        .eq('id', enigmaId)
                        .single();

                    if (!enigma) {
                        showToast('‚ùå √ânigme non trouv√©e', 'error');
                        return;
                    }

                    // Check if QR is configured using RPC
                    const { data: hasQR } = await supabase.rpc('enigma_has_qr', { p_enigma_id: enigmaId });
                    if (!hasQR) {
                        showToast('‚ùå QR Code non configur√© pour cette √©nigme', 'error');
                        return;
                    }

                    // Store enigmaId for the callback
                    this.currentScanEnigmaId = enigmaId;

                    // D√©terminer si on affiche les indices du jeu
                    const progress = await this.getProgress(enigmaId);
                    const hasGameClues = enigma.has_game && progress?.game_completed_at && enigma.game_clues && enigma.game_clues.length > 0;

                    // G√©n√©rer le contenu (indices ou emplacement)
                    let hintContent = '';
                    if (hasGameClues) {
                        hintContent = `
                            <div style="margin-bottom: 20px; max-width: 400px;">
                                <p style="color: #81FE0E; margin-bottom: 10px; font-weight: bold;">üîç Tes indices :</p>
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                                    ${enigma.game_clues.map(clue => `
                                        <div style="background: #343973; color: white; padding: 10px; border-radius: 6px; text-align: center; font-size: 0.9em;">
                                            ${typeof clue === 'object' ? clue.text : clue}
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                        `;
                    } else {
                        hintContent = `<p style="color: white; margin-bottom: 20px;">√ânigme #${enigma.number} - ${enigma.location}</p>`;
                    }

                    // Create modal
                    const modal = document.createElement('div');
                    modal.id = 'qrScannerModal';
                    modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 10000; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 20px;';
                    modal.innerHTML = `
                        <h2 style="color: #81FE0E; margin-bottom: 20px;">üì± Scan le QR Code</h2>
                        ${hintContent}
                        <div id="qrScanner" style="max-width: 500px; width: 100%;"></div>
                        <button class="btn btn-danger" style="margin-top: 20px;" onclick="hdnApp.closeQRScanner()">‚ùå Fermer</button>
                    `;
                    document.body.appendChild(modal);

                    // Stocker les infos pour le callback
                    this.currentScanEnigma = enigma;
                    this.currentScanHasGameClues = hasGameClues;

                    // Initialize scanner
                    this.qrScanner = new Html5Qrcode("qrScanner");

                    const self = this;
                    await this.qrScanner.start(
                        { facingMode: "environment" },
                        {
                            fps: 10,
                            qrbox: { width: 250, height: 250 }
                        },
                        async (decodedText) => {
                            // Stop scanner immediately
                            await self.qrScanner.stop();

                            // Validate QR using RPC (qr_secret never sent to client)
                            const { data: isValidQR, error: rpcError } = await supabase
                                .rpc('validate_qr_code', {
                                    p_enigma_id: self.currentScanEnigmaId,
                                    p_scanned_code: decodedText
                                });

                            if (rpcError) {
                                console.error('RPC Error:', rpcError);
                                showToast('‚ùå Erreur de validation', 'error');
                                return;
                            }

                            if (isValidQR) {
                                // Get progress to calculate points NOW
                                const progress = await self.getProgress(self.currentScanEnigmaId);

                                // Calculate POSITION points based on how many QR codes have been scanned for this enigma
                                let countQuery = supabase
                                    .from('enigma_progress')
                                    .select('id', { count: 'exact' })
                                    .eq('enigma_id', self.currentScanEnigmaId)
                                    .eq('qr_scanned', true);

                                const { count } = await countQuery;

                                // New point system: 125/100/75/50
                                let positionPoints = 50;
                                if (count === 0) positionPoints = 125;
                                else if (count === 1) positionPoints = 100;
                                else if (count === 2) positionPoints = 75;

                                // Calculate TIME BONUS
                                let timeBonus = 0;
                                if (progress.qr_hunt_started_at) {
                                    const huntStarted = new Date(progress.qr_hunt_started_at);
                                    const now = new Date();
                                    const elapsedMin = (now - huntStarted) / 60000;

                                    if (elapsedMin < 20) timeBonus = 20;
                                    else if (elapsedMin < 40) timeBonus = 10;
                                    else if (elapsedMin < 60) timeBonus = 5;
                                }

                                const totalPoints = positionPoints + timeBonus;

                                // Mark as scanned and store points
                                await self.updateProgress(progress.id, {
                                    qr_scanned: true,
                                    points_earned: totalPoints
                                });

                                // NOW award the points!
                                await self.awardPoints(totalPoints);

                                self.closeQRScanner();

                                // Build detailed message
                                let positionEmoji = 'üèÖ';
                                if (count === 0) positionEmoji = 'ü•á';
                                else if (count === 1) positionEmoji = 'ü•à';
                                else if (count === 2) positionEmoji = 'ü•â';

                                let bonusMsg = timeBonus > 0 ? `\n‚è±Ô∏è Bonus temps : +${timeBonus}` : '';

                                showToast(`‚úÖ QR Code valid√© !\n\n${positionEmoji} Position : +${positionPoints}${bonusMsg}\n\nüíé Total : +${totalPoints} points !`, 'success');
                                await self.loadEnigmes();
                                await self.loadUserData();
                            } else {
                                // Wrong QR - show message and restart scanner
                                const hintMsg = self.currentScanHasGameClues
                                    ? `Utilise tes indices du jeu pour le trouver !`
                                    : `Emplacement : ${enigma.location}`;
                                showToast(`‚ùå Mauvais QR code !\n\nTu dois scanner le QR de l'√©nigme #${enigma.number}\n${hintMsg}`, 'error');

                                // Restart scanner after 2 seconds
                                setTimeout(async () => {
                                    try {
                                        await self.qrScanner.start(
                                            { facingMode: "environment" },
                                            {
                                                fps: 10,
                                                qrbox: { width: 250, height: 250 }
                                            },
                                            arguments.callee
                                        );
                                    } catch (err) {
                                        console.error('Error restarting scanner:', err);
                                    }
                                }, 2000);
                            }
                        }
                    );

                } catch (error) {
                    console.error('Error opening QR scanner:', error);
                    showToast('‚ùå Erreur lors de l\'ouverture du scanner', 'error');
                }
            },

            // ========== QR HUNT (Je suis pr√™t) ==========

            async startQRHunt(enigmaId) {
                try {
                    const progress = await this.getProgress(enigmaId);

                    if (!progress || !progress.solved) {
                        showToast('‚ùå Tu dois d\'abord r√©soudre l\'√©nigme !', 'error');
                        return;
                    }

                    if (progress.qr_hunt_started_at) {
                        showToast('‚ö†Ô∏è Le chrono est d√©j√† lanc√© !', 'warning');
                        return;
                    }

                    // Start the hunt timer
                    const now = new Date().toISOString();
                    await this.updateProgress(progress.id, {
                        qr_hunt_started_at: now
                    });

                    showToast('üèÉ C\'est parti ! Trouve le QR Code le plus vite possible !', 'success');
                    await this.loadEnigmes();

                    // V√©rifier si l'onglet mini-jeu doit appara√Ætre
                    await this.checkMinigameAccess();

                } catch (error) {
                    console.error('Error starting QR hunt:', error);
                    showToast('‚ùå Erreur lors du lancement', 'error');
                }
            },

            // Live timer for QR hunt
            qrTimers: {},

            startQRTimer(enigmaId, startTime) {
                // Clear existing timer for this enigma if any
                if (this.qrTimers[enigmaId]) {
                    clearInterval(this.qrTimers[enigmaId]);
                }

                const updateTimer = () => {
                    const timerEl = document.getElementById(`qrTimer-${enigmaId}`);
                    const bonusEl = document.getElementById(`qrBonus-${enigmaId}`);

                    if (!timerEl || !bonusEl) {
                        clearInterval(this.qrTimers[enigmaId]);
                        return;
                    }

                    const now = new Date();
                    const elapsedMs = now - startTime;
                    const elapsedMin = Math.floor(elapsedMs / 60000);
                    const elapsedSec = Math.floor((elapsedMs % 60000) / 1000);

                    timerEl.textContent = `${elapsedMin}:${elapsedSec.toString().padStart(2, '0')}`;

                    // Update bonus display
                    let bonusText = '';
                    let color = '#ff4444';
                    if (elapsedMin < 20) {
                        bonusText = 'üî• +20 pts';
                        color = '#81FE0E';
                    } else if (elapsedMin < 40) {
                        bonusText = '‚ö° +10 pts';
                        color = '#81FE0E';
                    } else if (elapsedMin < 60) {
                        bonusText = '‚ú® +5 pts';
                        color = '#ffaa00';
                    } else {
                        bonusText = '‚è∞ Pas de bonus';
                        color = '#ff4444';
                    }

                    bonusEl.textContent = bonusText;
                    bonusEl.parentElement.style.color = color;
                };

                // Update immediately and then every second
                updateTimer();
                this.qrTimers[enigmaId] = setInterval(updateTimer, 1000);
            },

            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà SYST√àME DE JEU - √âPREUVE FINALE ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

            formatGameTime(startedAt) {
                const started = new Date(startedAt);
                const now = new Date();
                const elapsedMs = now - started;
                const elapsedMin = Math.floor(elapsedMs / 60000);
                const elapsedSec = Math.floor((elapsedMs % 60000) / 1000);
                return `${elapsedMin}:${elapsedSec.toString().padStart(2, '0')}`;
            },

            async startGame(enigmaId) {
                try {
                    const progress = await this.getProgress(enigmaId);

                    if (!progress || !progress.solved) {
                        showToast('‚ùå Tu dois d\'abord r√©soudre l\'√©nigme !', 'error');
                        return;
                    }

                    if (progress.game_completed_at) {
                        showToast('‚úÖ Tu as d√©j√† compl√©t√© le jeu !', 'info');
                        return;
                    }

                    // G√©n√©rer un token de jeu s√©curis√© via RPC
                    const { data: token, error } = await supabase.rpc('start_game_session', {
                        p_enigma_id: String(enigmaId),
                        p_player_id: String(this.currentUser.id),
                        p_team_id: this.currentUser.team_id ? String(this.currentUser.team_id) : null
                    });

                    if (error) {
                        console.error('Error starting game:', error);
                        // Message d'erreur plus d√©taill√© pour le debug
                        if (error.message.includes('function') || error.code === '42883') {
                            showToast('‚ùå La fonction RPC n\'existe pas. Ex√©cute le SQL dans Supabase !', 'error');
                        } else {
                            showToast('‚ùå Erreur: ' + error.message, 'error');
                        }
                        return;
                    }

                    if (!token) {
                        showToast('‚ùå Token non g√©n√©r√©. V√©rifie que l\'√©nigme est bien r√©solue.', 'error');
                        return;
                    }

                    // Afficher le jeu avec transition fluide
                    this.currentGameEnigmaId = enigmaId;
                    const gameUrl = `game.html?token=${token}`;
                    const container = document.getElementById('gameContainer');
                    const iframe = document.getElementById('gameIframe');

                    iframe.src = gameUrl;
                    container.style.display = 'block';
                    document.body.style.overflow = 'hidden';

                    // Fade in
                    requestAnimationFrame(() => {
                        container.style.opacity = '1';
                    });

                    showToast('üéÆ Jeu lanc√© ! Bonne chance !', 'success');

                } catch (error) {
                    console.error('Error starting game:', error);
                    showToast('‚ùå Erreur: ' + error.message, 'error');
                }
            },

            async resumeGame(enigmaId) {
                try {
                    const progress = await this.getProgress(enigmaId);

                    if (!progress || !progress.game_token) {
                        showToast('‚ùå Aucune partie en cours !', 'error');
                        return;
                    }

                    // Afficher le jeu avec transition fluide
                    this.currentGameEnigmaId = enigmaId;
                    const gameUrl = `game.html?token=${progress.game_token}`;
                    const container = document.getElementById('gameContainer');
                    const iframe = document.getElementById('gameIframe');

                    iframe.src = gameUrl;
                    container.style.display = 'block';
                    document.body.style.overflow = 'hidden';

                    // Fade in
                    requestAnimationFrame(() => {
                        container.style.opacity = '1';
                    });

                } catch (error) {
                    console.error('Error resuming game:', error);
                    showToast('‚ùå Erreur lors de la reprise du jeu', 'error');
                }
            },

            closeGame() {
                const container = document.getElementById('gameContainer');

                // Fade out
                container.style.opacity = '0';

                setTimeout(async () => {
                    container.style.display = 'none';
                    document.getElementById('gameIframe').src = '';
                    document.body.style.overflow = 'auto';
                    // Rafra√Æchir les √©nigmes et les donn√©es utilisateur pour voir le nouvel √©tat
                    await this.loadEnigmes();
                    await this.loadUserData();
                    // V√©rifier si l'onglet mini-jeu doit appara√Ætre
                    await this.checkMinigameAccess();
                }, 300);
            },

            // Appel√© par le jeu quand il est termin√© (via postMessage)
            // V√©rifier si l'√©quipe a d√©j√† compl√©t√© le jeu
            async checkTeamGameStatus(token) {
                try {
                    // Chercher la progression avec ce token
                    const { data: progress } = await supabase
                        .from('enigma_progress')
                        .select('game_completed_at, team_id')
                        .eq('game_token', token)
                        .maybeSingle();

                    if (!progress) return false;

                    // Si c'est un joueur solo, v√©rifier sa propre progression
                    if (!progress.team_id) {
                        return progress.game_completed_at !== null;
                    }

                    // Si c'est une √©quipe, v√©rifier si n'importe quel membre a d√©j√† compl√©t√©
                    const { data: teamProgress } = await supabase
                        .from('enigma_progress')
                        .select('game_completed_at')
                        .eq('team_id', progress.team_id)
                        .not('game_completed_at', 'is', null)
                        .limit(1);

                    return teamProgress && teamProgress.length > 0;
                } catch (error) {
                    console.error('Error checking team game status:', error);
                    return false;
                }
            },

            async handleGameComplete(token, score, totalTimeMs, deaths = 0) {
                try {
                    // R√©cup√©rer l'enigma_id et player_id √† partir du token
                    const { data: progress } = await supabase
                        .from('enigma_progress')
                        .select('enigma_id, player_id')
                        .eq('game_token', token)
                        .maybeSingle();

                    // Appeler la fonction RPC pour terminer le jeu
                    const { data: success, error } = await supabase.rpc('complete_game', {
                        p_token: token,
                        p_score: score
                    });

                    if (error) {
                        console.error('Error completing game:', error);
                        return false;
                    }

                    // Enregistrer le score dans le leaderboard (m√™me si l'√©quipe a d√©j√† compl√©t√©)
                    // Cela permet aux joueurs de continuer √† am√©liorer leur temps personnel
                    if (progress && progress.enigma_id && this.currentUser) {
                        try {
                            await supabase.rpc('submit_game_score', {
                                p_player_id: this.currentUser.id,
                                p_enigma_id: progress.enigma_id,
                                p_time_ms: totalTimeMs,
                                p_deaths: deaths
                            });
                        } catch (e) {
                            console.log('Could not submit to leaderboard:', e);
                        }
                    }

                    // Si complete_game retourne false, l'√©quipe a d√©j√† compl√©t√©
                    // Dans ce cas, on n'ajoute PAS les points
                    if (!success) {
                        console.log('Game already completed by team, no points awarded');
                        showToast('üë• Le jeu a d√©j√† √©t√© valid√© par ton √©quipe !', 'info');
                        // Rafra√Æchir quand m√™me l'affichage
                        await this.loadEnigmes();
                        await this.loadUserData();
                        return false;
                    }

                    // Ajouter les points bonus au joueur/√©quipe (seulement si c'est le premier)
                    if (score > 0) {
                        await this.awardPoints(score);
                    }

                    // Rafra√Æchir l'affichage
                    await this.loadEnigmes();
                    await this.loadUserData();

                    showToast(`üéÆ Jeu termin√© ! +${score} points bonus !`, 'success');
                    return true;

                } catch (error) {
                    console.error('Error handling game complete:', error);
                    return false;
                }
            },

            async closeQRScanner() {
                if (this.qrScanner) {
                    try {
                        await this.qrScanner.stop();
                    } catch (err) {
                        console.log('Scanner already stopped');
                    }
                    this.qrScanner = null;
                }
                const modal = document.getElementById('qrScannerModal');
                if (modal) {
                    modal.remove();
                }
            },

            // ========== CLASSEMENT ==========

            async loadClassement() {
                const container = document.getElementById('rankingList');
                container.innerHTML = '<div class="loading">Chargement du classement...</div>';

                try {
                    // Get solo players (exclude test accounts) - WITHOUT password
                    const { data: soloPlayers } = await supabase
                        .from('players')
                        .select('id, pseudo, points, team_id, is_test')
                        .is('team_id', null)
                        .eq('is_test', false);

                    // Get teams
                    const { data: teams } = await supabase
                        .from('teams')
                        .select('id, name, points');

                    // Create unified ranking array
                    let ranking = [];

                    // Add solo players
                    if (soloPlayers) {
                        soloPlayers.forEach(player => {
                            ranking.push({
                                type: 'solo',
                                name: player.pseudo,
                                points: player.points || 0,
                                members: null
                            });
                        });
                    }

                    // Add teams
                    if (teams) {
                        for (const team of teams) {
                            // Get team members
                            const { data: members } = await supabase
                                .from('players')
                                .select('pseudo')
                                .eq('team_id', team.id);

                            ranking.push({
                                type: 'team',
                                name: team.name,
                                points: team.points || 0,
                                members: members ? members.map(m => m.pseudo).join(', ') : ''
                            });
                        }
                    }

                    // Sort by points (descending)
                    ranking.sort((a, b) => b.points - a.points);

                    // Display unified ranking
                    container.innerHTML = '';

                    if (ranking.length === 0) {
                        container.innerHTML = '<p style="text-align: center; color: #666;">Aucun joueur dans le classement.</p>';
                        return;
                    }

                    const header = document.createElement('h3');
                    header.textContent = 'üèÜ Classement G√©n√©ral';
                    container.appendChild(header);

                    ranking.forEach((entry, index) => {
                        const rankDiv = document.createElement('div');
                        rankDiv.className = 'ranking-item';

                        let posClass = '';
                        if (index === 0) posClass = 'first';
                        else if (index === 1) posClass = 'second';
                        else if (index === 2) posClass = 'third';

                        const typeLabel = entry.type === 'solo' ? 'üë§ Solo' : 'üë• √âquipe';
                        const membersHtml = entry.members
                            ? `<p style="font-size: 0.85em; color: #666; margin-top: 5px;">${entry.members}</p>`
                            : '';

                        rankDiv.innerHTML = `
                <div class="ranking-position ${posClass}">#${index + 1}</div>
                <div class="ranking-info">
                    <strong>${entry.name}</strong>
                    <span style="font-size: 0.9em; color: #81FE0E; margin-left: 10px;">${typeLabel}</span>
                    ${membersHtml}
                </div>
                <div class="ranking-points">${entry.points} pts</div>
            `;
                        container.appendChild(rankDiv);
                    });

                } catch (error) {
                    console.error('Error loading ranking:', error);
                    container.innerHTML = '<p style="color: #ff4444;">Erreur lors du chargement du classement.</p>';
                }
            },

            // ========== MINI-JEU LEADERBOARD ==========

            gameEnigmaId: null, // ID de l'√©nigme avec has_game

            async loadGameLeaderboard() {
                const container = document.getElementById('minigameLeaderboard');
                if (!container) return;

                container.innerHTML = '<div class="loading">Chargement du classement...</div>';

                try {
                    // Trouver l'√©nigme avec has_game
                    const { data: gameEnigma, error: enigmaError } = await supabase
                        .from('enigmas')
                        .select('id')
                        .eq('has_game', true)
                        .eq('published', true)
                        .limit(1)
                        .maybeSingle();

                    if (enigmaError) {
                        console.error('Error finding game enigma:', enigmaError);
                        container.innerHTML = '<p style="color: #ff4444;">Erreur: impossible de trouver l\'√©nigme du jeu.</p>';
                        return;
                    }

                    if (!gameEnigma) {
                        container.innerHTML = '<p style="text-align: center; color: #666;">Aucun mini-jeu disponible.</p>';
                        return;
                    }

                    this.gameEnigmaId = gameEnigma.id;

                    // R√©cup√©rer le classement via RPC
                    const { data: leaderboard, error } = await supabase.rpc('get_game_leaderboard', {
                        p_enigma_id: gameEnigma.id
                    });

                    if (error) {
                        console.error('Error loading leaderboard:', error);
                        // Si la fonction n'existe pas, afficher un message explicite
                        if (error.code === '42883' || error.message.includes('function')) {
                            container.innerHTML = `
                                <div style="text-align: center; padding: 20px;">
                                    <p style="color: #ff4444; margin-bottom: 10px;">‚ö†Ô∏è Le classement n'est pas encore configur√©.</p>
                                    <p style="color: #666; font-size: 0.9em;">Demande √† l'admin d'ex√©cuter le SQL "game_leaderboard.sql"</p>
                                </div>
                            `;
                        } else {
                            container.innerHTML = `<p style="color: #ff4444;">Erreur: ${error.message}</p>`;
                        }
                        return;
                    }

                    if (!leaderboard || leaderboard.length === 0) {
                        container.innerHTML = '<p style="text-align: center; color: #666;">Aucun score enregistr√©. Sois le premier √† terminer le jeu !</p>';
                        return;
                    }

                    // Afficher le classement
                    let html = `
                        <table style="width: 100%; border-collapse: collapse; margin-top: 15px;">
                            <thead>
                                <tr style="background: #343973; color: white;">
                                    <th style="padding: 12px; text-align: center; border-radius: 8px 0 0 0;">#</th>
                                    <th style="padding: 12px; text-align: left;">Joueur</th>
                                    <th style="padding: 12px; text-align: center;">‚è±Ô∏è Temps</th>
                                    <th style="padding: 12px; text-align: center; border-radius: 0 8px 0 0;">üíÄ Morts</th>
                                </tr>
                            </thead>
                            <tbody>
                    `;

                    leaderboard.forEach((entry, index) => {
                        // Formater le temps
                        const totalSec = Math.floor(entry.time_ms / 1000);
                        const min = Math.floor(totalSec / 60);
                        const sec = totalSec % 60;
                        const timeStr = `${min}:${sec.toString().padStart(2, '0')}`;

                        // M√©daille pour le top 3
                        let medal = '';
                        if (index === 0) medal = 'ü•á';
                        else if (index === 1) medal = 'ü•à';
                        else if (index === 2) medal = 'ü•â';

                        // Highlight si c'est l'utilisateur actuel
                        const isCurrentUser = entry.player_id === this.currentUser?.id;
                        const rowStyle = isCurrentUser
                            ? 'background: rgba(129, 254, 14, 0.15); font-weight: bold;'
                            : (index % 2 === 0 ? 'background: #f8f9fa;' : '');

                        html += `
                            <tr style="${rowStyle}">
                                <td style="padding: 12px; text-align: center; font-weight: bold;">
                                    ${medal || entry.rank}
                                </td>
                                <td style="padding: 12px;">
                                    ${entry.player_name}
                                    ${isCurrentUser ? '<span style="color: #81FE0E; margin-left: 8px;">‚Üê Toi</span>' : ''}
                                </td>
                                <td style="padding: 12px; text-align: center; font-family: monospace; font-size: 1.1em;">
                                    ${timeStr}
                                </td>
                                <td style="padding: 12px; text-align: center;">
                                    ${entry.deaths}
                                </td>
                            </tr>
                        `;
                    });

                    html += '</tbody></table>';

                    // Ajouter la date de mise √† jour
                    html += `
                        <p style="text-align: center; color: #888; font-size: 0.85em; margin-top: 15px;">
                            Classement bas√© sur le meilleur temps de chaque joueur
                        </p>
                    `;

                    container.innerHTML = html;

                } catch (error) {
                    console.error('Error loading game leaderboard:', error);
                    container.innerHTML = '<p style="color: #ff4444;">Erreur lors du chargement du classement.</p>';
                }
            },

            async playMinigame() {
                if (!this.gameEnigmaId) {
                    // Trouver l'√©nigme avec has_game
                    const { data: gameEnigma } = await supabase
                        .from('enigmas')
                        .select('id')
                        .eq('has_game', true)
                        .eq('published', true)
                        .limit(1)
                        .maybeSingle();

                    if (!gameEnigma) {
                        showToast('‚ùå Aucun mini-jeu disponible', 'error');
                        return;
                    }
                    this.gameEnigmaId = gameEnigma.id;
                }

                // Mode fun - pas besoin de token, juste pour le classement
                const gameUrl = `game.html?mode=fun&player_id=${this.currentUser.id}&enigma_id=${this.gameEnigmaId}`;
                const container = document.getElementById('gameContainer');
                const iframe = document.getElementById('gameIframe');

                iframe.src = gameUrl;
                container.style.display = 'block';
                document.body.style.overflow = 'hidden';

                requestAnimationFrame(() => {
                    container.style.opacity = '1';
                });

                showToast('üéÆ Mode fun ! Bats ton record !', 'success');
            },

            // V√©rifier si l'onglet mini-jeu doit √™tre affich√©
            async checkMinigameAccess() {
                try {
                    // Trouver l'√©nigme avec has_game
                    const { data: gameEnigma } = await supabase
                        .from('enigmas')
                        .select('id')
                        .eq('has_game', true)
                        .eq('published', true)
                        .limit(1)
                        .maybeSingle();

                    if (!gameEnigma) {
                        document.getElementById('minigameNavBtn')?.classList.add('hidden');
                        return;
                    }

                    // V√©rifier si le joueur a commenc√© la chasse au QR
                    const progress = await this.getProgress(gameEnigma.id);

                    // Afficher l'onglet si qr_hunt_started_at est d√©fini
                    const minigameBtn = document.getElementById('minigameNavBtn');
                    if (minigameBtn) {
                        if (progress && progress.qr_hunt_started_at) {
                            minigameBtn.classList.remove('hidden');
                        } else {
                            minigameBtn.classList.add('hidden');
                        }
                    }
                } catch (error) {
                    console.error('Error checking minigame access:', error);
                }
            },

            // ========== ADMIN PANEL ==========

            async loadAdminPanel() {
                if (!this.currentUser.is_admin) {
                    showToast('‚ùå Acc√®s refus√©', 'error');
                    return;
                }

                // Load stats
                const { data: players } = await supabase.from('players').select('id', { count: 'exact' });
                const { data: enigmas } = await supabase.from('enigmas').select('id', { count: 'exact' });
                const { data: pending } = await supabase
                    .from('submissions')
                    .select('id', { count: 'exact' })
                    .eq('status', 'pending');

                document.getElementById('adminTotalPlayers').textContent = players?.length || 0;
                document.getElementById('adminTotalEnigmas').textContent = enigmas?.length || 0;
                document.getElementById('adminPendingValidations').textContent = pending?.length || 0;

                // Load enigmas list
                await this.loadAdminEnigmas();

                // Load pending validations
                await this.loadPendingValidations();
            },

            async loadAdminEnigmas() {
                const container = document.getElementById('adminEnigmasList');

                try {
                    const { data: enigmas } = await supabase
                        .from('enigmas')
                        .select('*')
                        .order('number', { ascending: true });

                    if (!enigmas || enigmas.length === 0) {
                        container.innerHTML = '<p style="color: #666;">Aucune √©nigme cr√©√©e.</p>';
                        return;
                    }

                    container.innerHTML = '';

                    enigmas.forEach(enigma => {
                        const div = document.createElement('div');
                        div.style.cssText = 'background: #f9f9f9; padding: 15px; margin: 10px 0; border-radius: 8px; border-left: 4px solid #343973;';

                        div.innerHTML = `
                            <h4 style="color: #343973; margin-bottom: 10px;">
                                √ânigme #${enigma.number} - ${enigma.title}
                                ${enigma.published ? '<span class="badge badge-success">Publi√©e</span>' : '<span class="badge badge-warning">Brouillon</span>'}
                                ${enigma.scheduled_at ? `<span class="badge badge-primary">Programm√©e: ${formatParisDateTime(enigma.scheduled_at)}</span>` : ''}
                            </h4>
                            <p style="color: #666; margin: 5px 0;">R√©ponse: ${enigma.answer}</p>
                            <p style="color: #666; margin: 5px 0;">Lieu QR: ${enigma.location}</p>
                            <p style="color: #666; margin: 5px 0;">Code QR: <strong>${enigma.qr_secret}</strong></p>
                            ${enigma.image_url ? `<p style="color: #666; margin: 5px 0;">üì∑ Image: <a href="${enigma.image_url}" target="_blank" style="color: #343973;">Voir</a></p>` : ''}
                            <div style="margin-top: 10px;">
                                <button class="btn btn-primary" onclick="hdnApp.generateAndShowQR('${enigma.qr_secret}', ${enigma.number})">üì• T√©l√©charger QR</button>
                                <button class="btn btn-primary" onclick="hdnApp.editEnigma(${enigma.id})">‚úèÔ∏è Modifier</button>
                                <button class="btn ${enigma.published ? 'btn-warning' : 'btn-success'}" 
                                        onclick="hdnApp.togglePublish(${enigma.id}, ${!enigma.published})">
                                    ${enigma.published ? 'üì• D√©publier' : 'üì§ Publier'}
                                </button>
                                ${enigma.published ? `<button class="btn btn-success" onclick="hdnApp.showNotifyModal(${enigma.id}, ${enigma.number}, '${enigma.title.replace(/'/g, "\\'")}')">üìß Notifier</button>` : ''}
                                <button class="btn btn-danger" onclick="hdnApp.deleteEnigma(${enigma.id})">üóëÔ∏è Supprimer</button>
                            </div>
                            <div id="qr-display-${enigma.number}" class="qr-code-container hidden"></div>
                        `;

                        container.appendChild(div);
                    });

                } catch (error) {
                    console.error('Error loading admin enigmas:', error);
                    container.innerHTML = '<p style="color: #ff4444;">Erreur lors du chargement.</p>';
                }
            },

            // ========== QR CODE GENERATION ==========

            generateAndShowQR(qrSecret, enigmaNumber) {
                const container = document.getElementById(`qr-display-${enigmaNumber}`);

                // Toggle visibility
                if (!container.classList.contains('hidden')) {
                    container.classList.add('hidden');
                    container.innerHTML = '';
                    return;
                }

                container.classList.remove('hidden');
                container.innerHTML = `
                    <h4 style="color: #343973; margin-bottom: 10px;">QR Code pour √ânigme #${enigmaNumber}</h4>
                    <p style="color: #666; margin-bottom: 10px;">Code: <strong>${qrSecret}</strong></p>
                    <div id="qrcode-${enigmaNumber}"></div>
                    <button class="btn btn-success" style="margin-top: 10px;" onclick="hdnApp.downloadQR(${enigmaNumber})">
                        üíæ T√©l√©charger l'image
                    </button>
                `;

                // Generate QR Code
                new QRCode(document.getElementById(`qrcode-${enigmaNumber}`), {
                    text: qrSecret,
                    width: 256,
                    height: 256,
                    colorDark: "#000000",
                    colorLight: "#ffffff",
                    correctLevel: QRCode.CorrectLevel.H
                });
            },

            downloadQR(enigmaNumber) {
                const canvas = document.querySelector(`#qrcode-${enigmaNumber} canvas`);
                if (!canvas) {
                    showToast('‚ùå QR Code non trouv√©', 'error');
                    return;
                }

                // Convert to blob and download
                canvas.toBlob(blob => {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `HDN-QRCode-Enigme-${enigmaNumber}.png`;
                    a.click();
                    URL.revokeObjectURL(url);
                    showToast('‚úÖ QR Code t√©l√©charg√© !', 'success');
                });
            },

            async togglePublish(enigmaId, shouldPublish) {
                try {
                    const { error } = await supabase
                        .from('enigmas')
                        .update({ published: shouldPublish })
                        .eq('id', enigmaId);

                    if (error) throw error;

                    showToast(shouldPublish ? '‚úÖ √ânigme publi√©e !' : '‚úÖ √ânigme d√©publi√©e !', 'success');
                    await this.loadAdminEnigmas();

                } catch (error) {
                    console.error('Error:', error);
                    showToast('‚ùå Erreur lors de la modification', 'error');
                }
            },

            async deleteEnigma(enigmaId) {
                if (!confirm('Es-tu s√ªr de vouloir supprimer cette √©nigme ?')) return;

                try {
                    const { error } = await supabase
                        .from('enigmas')
                        .delete()
                        .eq('id', enigmaId);

                    if (error) throw error;

                    showToast('‚úÖ √ânigme supprim√©e !', 'success');

                    // Renumber remaining enigmas
                    const { data: remaining } = await supabase
                        .from('enigmas')
                        .select('*')
                        .order('number', { ascending: true });

                    for (let i = 0; i < remaining.length; i++) {
                        await supabase
                            .from('enigmas')
                            .update({ number: i + 1 })
                            .eq('id', remaining[i].id);
                    }

                    await this.loadAdminEnigmas();

                } catch (error) {
                    console.error('Error:', error);
                    showToast('‚ùå Erreur lors de la suppression', 'error');
                }
            },

            async editEnigma(enigmaId) {
                try {
                    const { data: enigma } = await supabase
                        .from('enigmas')
                        .select('*')
                        .eq('id', enigmaId)
                        .single();

                    if (!enigma) return;

                    // Fill form with current data
                    document.getElementById('enigmaTitle').value = enigma.title;
                    document.getElementById('enigmaDescription').value = enigma.description;
                    document.getElementById('enigmaImageUrl').value = enigma.image_url || '';
                    document.getElementById('enigmaAnswer').value = enigma.answer;
                    document.getElementById('enigmaLocation').value = enigma.location;
                    document.getElementById('enigmaValidation').value = enigma.validation_type;
                    document.getElementById('enigmaHasGame').checked = enigma.has_game || false;

                    // Game clues setup
                    const hasGameChecked = enigma.has_game || false;
                    document.getElementById('gameCluesSection').style.display = hasGameChecked ? 'block' : 'none';
                    if (enigma.game_clues && Array.isArray(enigma.game_clues)) {
                        enigma.game_clues.forEach((clue, index) => {
                            const levelEl = document.getElementById(`gameClueLevel${index + 1}`);
                            const clueEl = document.getElementById(`gameClue${index + 1}`);
                            if (levelEl) levelEl.value = clue.level || '';
                            if (clueEl) clueEl.value = clue.text || '';
                        });
                    } else {
                        // Reset game clues
                        for (let i = 1; i <= 4; i++) {
                            document.getElementById(`gameClue${i}`).value = '';
                        }
                    }

                    document.getElementById('enigmaHint1').value = enigma.hint1 || '';
                    document.getElementById('enigmaHint2').value = enigma.hint2 || '';
                    document.getElementById('enigmaHint3').value = enigma.hint3 || '';
                    document.getElementById('enigmaPublished').checked = enigma.published;

                    // Audio setup
                    audioToRemove = false;
                    const hasAudio = !!enigma.audio_url;
                    document.getElementById('enigmaHasAudio').checked = hasAudio;
                    document.getElementById('audioUploadSection').style.display = hasAudio ? 'block' : 'none';
                    document.getElementById('enigmaAudioFile').value = '';

                    if (hasAudio) {
                        document.getElementById('currentAudioUrl').style.display = 'block';
                        document.getElementById('currentAudioLink').href = enigma.audio_url;
                        document.getElementById('currentAudioLink').textContent = enigma.audio_url.split('/').pop();
                    } else {
                        document.getElementById('currentAudioUrl').style.display = 'none';
                    }

                    if (enigma.scheduled_at) {
                        // Convert to Paris time for the datetime-local input
                        const parisDate = toParisTime(enigma.scheduled_at);
                        const year = parisDate.getFullYear();
                        const month = String(parisDate.getMonth() + 1).padStart(2, '0');
                        const day = String(parisDate.getDate()).padStart(2, '0');
                        const hours = String(parisDate.getHours()).padStart(2, '0');
                        const minutes = String(parisDate.getMinutes()).padStart(2, '0');
                        document.getElementById('enigmaSchedule').value = `${year}-${month}-${day}T${hours}:${minutes}`;
                    }

                    // Change button to "Update"
                    const btn = document.querySelector('#admin-section .btn-success');
                    btn.textContent = 'üíæ Mettre √† jour';
                    btn.onclick = () => this.updateEnigma(enigmaId);

                    // Scroll to form
                    document.getElementById('enigmaTitle').scrollIntoView({ behavior: 'smooth', block: 'center' });

                } catch (error) {
                    console.error('Error:', error);
                    showToast('‚ùå Erreur lors du chargement', 'error');
                }
            },

            async updateEnigma(enigmaId) {
                const title = document.getElementById('enigmaTitle').value.trim();
                const description = document.getElementById('enigmaDescription').value.trim();
                const imageUrl = document.getElementById('enigmaImageUrl').value.trim();
                const answer = document.getElementById('enigmaAnswer').value.trim();
                const location = document.getElementById('enigmaLocation').value.trim();
                const validationType = document.getElementById('enigmaValidation').value;
                const hasGame = document.getElementById('enigmaHasGame').checked;

                // R√©cup√©rer les indices du jeu
                const gameClues = [];
                if (hasGame) {
                    for (let i = 1; i <= 4; i++) {
                        const level = document.getElementById(`gameClueLevel${i}`).value;
                        const text = document.getElementById(`gameClue${i}`).value.trim();
                        if (text) {
                            gameClues.push({ level: parseInt(level), text: text });
                        }
                    }
                }

                const hint1 = document.getElementById('enigmaHint1').value.trim();
                const hint2 = document.getElementById('enigmaHint2').value.trim();
                const hint3 = document.getElementById('enigmaHint3').value.trim();
                const published = document.getElementById('enigmaPublished').checked;
                const schedule = document.getElementById('enigmaSchedule').value;

                if (!title || !description || !answer || !location) {
                    showToast('‚ùå Remplis tous les champs obligatoires !', 'error');
                    return;
                }

                try {
                    // Get current enigma to preserve QR secret and audio
                    const { data: currentEnigma } = await supabase
                        .from('enigmas')
                        .select('qr_secret, audio_url')
                        .eq('id', enigmaId)
                        .single();

                    // Generate new QR secret if not exists
                    let qrSecret = currentEnigma?.qr_secret;
                    if (!qrSecret) {
                        qrSecret = 'HDN-E' + enigmaId + '-' + Math.random().toString(36).substr(2, 6).toUpperCase();
                    }

                    // Handle audio upload
                    let audioUrl = currentEnigma?.audio_url || null;
                    const audioFile = document.getElementById('enigmaAudioFile').files[0];

                    if (audioToRemove) {
                        audioUrl = null;
                    } else if (audioFile) {
                        showToast('üì§ Upload de l\'audio en cours...', 'info');
                        audioUrl = await this.uploadAudio(audioFile, enigmaId);
                    }

                    const { error } = await supabase
                        .from('enigmas')
                        .update({
                            title: title,
                            description: description,
                            image_url: imageUrl || null,
                            audio_url: audioUrl,
                            answer: answer,
                            location: location,
                            qr_secret: qrSecret,
                            validation_type: validationType,
                            has_game: hasGame,
                            game_clues: gameClues.length > 0 ? gameClues : null,
                            hint1: hint1 || null,
                            hint2: hint2 || null,
                            hint3: hint3 || null,
                            published: published,
                            scheduled_at: this.convertLocalToUTC(schedule)
                        })
                        .eq('id', enigmaId);

                    if (error) throw error;

                    showToast('‚úÖ √ânigme mise √† jour !', 'success');

                    // Reset form
                    this.resetEnigmaForm();
                    document.getElementById('enigmaSchedule').value = '';
                    audioToRemove = false;

                    // Change button back
                    const btn = document.querySelector('#admin-section .btn-success');
                    btn.textContent = '‚úÖ Cr√©er l\'√©nigme';
                    btn.onclick = () => this.createEnigma();

                    // Reload list
                    await this.loadAdminEnigmas();

                } catch (error) {
                    console.error('Error:', error);
                    showToast('‚ùå Erreur lors de la mise √† jour : ' + error.message, 'error');
                }
            },

            // Upload audio to Supabase Storage
            async uploadAudio(file, enigmaId) {
                const fileName = `enigma-${enigmaId}-${Date.now()}.mp3`;

                const { data, error } = await supabase.storage
                    .from('audio')
                    .upload(fileName, file, {
                        cacheControl: '3600',
                        upsert: true
                    });

                if (error) throw error;

                // Get public URL
                const { data: urlData } = supabase.storage
                    .from('audio')
                    .getPublicUrl(fileName);

                return urlData.publicUrl;
            },

            async createEnigma() {
                const title = document.getElementById('enigmaTitle').value.trim();
                const description = document.getElementById('enigmaDescription').value.trim();
                const imageUrl = document.getElementById('enigmaImageUrl').value.trim();
                const answer = document.getElementById('enigmaAnswer').value.trim();
                const location = document.getElementById('enigmaLocation').value.trim();
                const validationType = document.getElementById('enigmaValidation').value;
                const hasGame = document.getElementById('enigmaHasGame').checked;

                // R√©cup√©rer les indices du jeu
                const gameClues = [];
                if (hasGame) {
                    for (let i = 1; i <= 4; i++) {
                        const level = document.getElementById(`gameClueLevel${i}`).value;
                        const text = document.getElementById(`gameClue${i}`).value.trim();
                        if (text) {
                            gameClues.push({ level: parseInt(level), text: text });
                        }
                    }
                }

                const hint1 = document.getElementById('enigmaHint1').value.trim();
                const hint2 = document.getElementById('enigmaHint2').value.trim();
                const hint3 = document.getElementById('enigmaHint3').value.trim();
                const published = document.getElementById('enigmaPublished').checked;
                const schedule = document.getElementById('enigmaSchedule').value;

                if (!title || !description || !answer || !location) {
                    showToast('‚ùå Remplis tous les champs obligatoires !', 'error');
                    return;
                }

                try {
                    // Get next number (max + 1)
                    const { data: existingEnigmas } = await supabase
                        .from('enigmas')
                        .select('number')
                        .order('number', { ascending: false })
                        .limit(1);

                    const nextNumber = existingEnigmas && existingEnigmas.length > 0
                        ? existingEnigmas[0].number + 1
                        : 1;

                    // Generate QR secret automatically
                    const qrSecret = 'HDN-E' + nextNumber + '-' + Math.random().toString(36).substr(2, 6).toUpperCase();

                    // Create enigma first
                    const { data: newEnigma, error } = await supabase
                        .from('enigmas')
                        .insert([{
                            number: nextNumber,
                            title: title,
                            description: description,
                            image_url: imageUrl || null,
                            answer: answer,
                            location: location,
                            validation_type: validationType,
                            has_game: hasGame,
                            game_clues: gameClues.length > 0 ? gameClues : null,
                            hint1: hint1 || null,
                            hint2: hint2 || null,
                            hint3: hint3 || null,
                            qr_secret: qrSecret,
                            published: published,
                            scheduled_at: this.convertLocalToUTC(schedule)
                        }])
                        .select()
                        .single();

                    if (error) throw error;

                    // Handle audio upload if present
                    const audioFile = document.getElementById('enigmaAudioFile').files[0];
                    if (audioFile && document.getElementById('enigmaHasAudio').checked) {
                        showToast('üì§ Upload de l\'audio en cours...', 'info');
                        const audioUrl = await this.uploadAudio(audioFile, newEnigma.id);

                        // Update enigma with audio URL
                        await supabase
                            .from('enigmas')
                            .update({ audio_url: audioUrl })
                            .eq('id', newEnigma.id);
                    }

                    showToast(`‚úÖ √ânigme #${nextNumber} cr√©√©e !\n\nCode QR: ${qrSecret}`, 'success');

                    // Reset form
                    this.resetEnigmaForm();
                    document.getElementById('enigmaSchedule').value = '';
                    audioToRemove = false;

                    // Reload list
                    await this.loadAdminEnigmas();

                } catch (error) {
                    console.error('Error:', error);
                    showToast('‚ùå Erreur lors de la cr√©ation : ' + error.message, 'error');
                }
            },

            resetEnigmaForm() {
                document.getElementById('enigmaTitle').value = '';
                document.getElementById('enigmaDescription').value = '';
                document.getElementById('enigmaImageUrl').value = '';
                document.getElementById('enigmaAnswer').value = '';
                document.getElementById('enigmaLocation').value = '';
                document.getElementById('enigmaValidation').value = 'auto';
                document.getElementById('enigmaHasGame').checked = false;
                document.getElementById('enigmaHint1').value = '';
                document.getElementById('enigmaHint2').value = '';
                document.getElementById('enigmaHint3').value = '';
                document.getElementById('enigmaPublished').checked = false;

                // Reset game clues
                document.getElementById('gameCluesSection').style.display = 'none';
                for (let i = 1; i <= 4; i++) {
                    document.getElementById(`gameClue${i}`).value = '';
                }

                // Reset audio fields
                document.getElementById('enigmaHasAudio').checked = false;
                document.getElementById('audioUploadSection').style.display = 'none';
                document.getElementById('enigmaAudioFile').value = '';
                document.getElementById('currentAudioUrl').style.display = 'none';
                audioToRemove = false;
            },

            async loadPendingValidations() {
                const container = document.getElementById('pendingValidationsList');

                try {
                    const { data: submissions } = await supabase
                        .from('submissions')
                        .select(`
                            *,
                            enigmas (title, number, answer),
                            players (pseudo)
                        `)
                        .eq('status', 'pending')
                        .order('created_at', { ascending: true });

                    if (!submissions || submissions.length === 0) {
                        container.innerHTML = '<p style="color: #666;">Aucune validation en attente.</p>';
                        return;
                    }

                    container.innerHTML = '';

                    submissions.forEach(sub => {
                        const div = document.createElement('div');
                        div.style.cssText = 'background: #f9f9f9; padding: 15px; margin: 10px 0; border-radius: 8px; border-left: 4px solid #ffaa00;';

                        const pseudo = sub.players?.pseudo || '√âquipe';
                        const enigmaTitle = sub.enigmas?.title || '√ânigme inconnue';
                        const correctAnswer = sub.enigmas?.answer || '';

                        div.innerHTML = `
                            <h4 style="color: #343973; margin-bottom: 10px;">
                                ${pseudo} - √ânigme #${sub.enigmas?.number} : ${enigmaTitle}
                            </h4>
                            <p style="color: #666; margin: 5px 0;"><strong>R√©ponse propos√©e :</strong> ${sub.answer}</p>
                            <p style="color: #666; margin: 5px 0;"><strong>R√©ponse correcte :</strong> ${correctAnswer}</p>
                            <div style="margin-top: 10px;">
                                <button class="btn btn-success" onclick="hdnApp.validateSubmission(${sub.id}, true)">‚úÖ Accepter</button>
                                <button class="btn btn-danger" onclick="hdnApp.validateSubmission(${sub.id}, false)">‚ùå Refuser</button>
                            </div>
                        `;

                        container.appendChild(div);
                    });

                } catch (error) {
                    console.error('Error loading pending validations:', error);
                    container.innerHTML = '<p style="color: #ff4444;">Erreur lors du chargement.</p>';
                }
            },

            async validateSubmission(submissionId, accepted) {
                try {
                    // Get submission details
                    const { data: submission } = await supabase
                        .from('submissions')
                        .select('*')
                        .eq('id', submissionId)
                        .single();

                    if (!submission) return;

                    // Update submission status
                    await supabase
                        .from('submissions')
                        .update({ status: accepted ? 'accepted' : 'rejected' })
                        .eq('id', submissionId);

                    if (accepted) {
                        // Get progress
                        let query = supabase
                            .from('enigma_progress')
                            .select('*')
                            .eq('enigma_id', submission.enigma_id);

                        if (submission.team_id) {
                            query = query.eq('team_id', submission.team_id);
                        } else {
                            query = query.eq('player_id', submission.player_id);
                        }

                        const { data: progress } = await query.maybeSingle();

                        if (progress) {
                            // Mark as solved but DON'T calculate points yet (will be done at QR scan)
                            await supabase
                                .from('enigma_progress')
                                .update({
                                    solved: true,
                                    solved_at: new Date().toISOString(),
                                    points_earned: 0
                                })
                                .eq('id', progress.id);
                        }
                    }

                    showToast(accepted ? '‚úÖ R√©ponse accept√©e !' : '‚ùå R√©ponse refus√©e !', accepted ? 'success' : 'error');
                    await this.loadPendingValidations();
                    await this.loadAdminPanel();

                } catch (error) {
                    console.error('Error:', error);
                    showToast('‚ùå Erreur lors de la validation', 'error');
                }
            },

            // ========== EMAIL NOTIFICATIONS ==========

            WORKER_URL: 'https://hdn-mailer.arthurbdn.workers.dev',

            async showNotifyModal(enigmaId, enigmaNumber, enigmaTitle) {
                showToast('‚è≥ Analyse des joueurs...', 'info');

                try {
                    // R√©cup√©rer tous les joueurs avec leur email
                    const { data: players } = await supabase
                        .from('players')
                        .select('id, pseudo, email, team_id, is_admin, is_test')
                        .eq('is_admin', false)
                        .eq('is_test', false);

                    if (!players || players.length === 0) {
                        showToast('‚ùå Aucun joueur trouv√©', 'error');
                        return;
                    }

                    // Pour chaque joueur, v√©rifier s'il a r√©solu l'√©nigme pr√©c√©dente
                    const previousEnigmaNumber = enigmaNumber - 1;

                    let playersUpToDate = [];
                    let playersBehind = [];

                    if (previousEnigmaNumber < 1) {
                        // Premi√®re √©nigme : tout le monde est "√† jour"
                        playersUpToDate = players.filter(p => p.email);
                    } else {
                        // R√©cup√©rer l'ID de l'√©nigme pr√©c√©dente
                        const { data: prevEnigma } = await supabase
                            .from('enigmas')
                            .select('id')
                            .eq('number', previousEnigmaNumber)
                            .single();

                        if (!prevEnigma) {
                            showToast('‚ùå √ânigme pr√©c√©dente non trouv√©e', 'error');
                            return;
                        }

                        // R√©cup√©rer les progress de l'√©nigme pr√©c√©dente
                        const { data: progressList } = await supabase
                            .from('enigma_progress')
                            .select('player_id, team_id, solved')
                            .eq('enigma_id', prevEnigma.id)
                            .eq('solved', true);

                        const solvedPlayerIds = new Set(progressList?.filter(p => p.player_id).map(p => p.player_id) || []);
                        const solvedTeamIds = new Set(progressList?.filter(p => p.team_id).map(p => p.team_id) || []);

                        for (const player of players) {
                            if (!player.email) continue;

                            const hasSolved = player.team_id
                                ? solvedTeamIds.has(player.team_id)
                                : solvedPlayerIds.has(player.id);

                            if (hasSolved) {
                                playersUpToDate.push(player);
                            } else {
                                playersBehind.push(player);
                            }
                        }
                    }

                    // Afficher la modal de confirmation
                    const modal = document.createElement('div');
                    modal.id = 'notifyModal';
                    modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 10000; display: flex; align-items: center; justify-content: center; padding: 20px;';
                    modal.innerHTML = `
                        <div style="background: white; padding: 30px; border-radius: 15px; max-width: 500px; width: 100%;">
                            <h3 style="color: #343973; margin-bottom: 20px;">üìß Notifier les joueurs</h3>
                            <p style="color: #666; margin-bottom: 15px;">
                                <strong>√ânigme #${enigmaNumber}</strong> - ${enigmaTitle}
                            </p>
                            
                            <div style="background: #e8f5e9; padding: 15px; border-radius: 8px; margin-bottom: 10px;">
                                <p style="color: #2e7d32; margin: 0; font-weight: bold;">
                                    ‚úÖ Joueurs √† jour : ${playersUpToDate.length}
                                </p>
                                <p style="color: #666; font-size: 12px; margin: 5px 0 0 0;">
                                    Recevront : "Sois le premier √† r√©soudre !"
                                </p>
                            </div>
                            
                            <div style="background: #fff3e0; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                                <p style="color: #e65100; margin: 0; font-weight: bold;">
                                    ‚ö†Ô∏è Joueurs en retard : ${playersBehind.length}
                                </p>
                                <p style="color: #666; font-size: 12px; margin: 5px 0 0 0;">
                                    Recevront : "Tu as du retard, rattrape-toi !"
                                </p>
                            </div>

                            <p style="color: #333; font-weight: bold; margin-bottom: 15px;">
                                üì¨ Total : ${playersUpToDate.length + playersBehind.length} emails √† envoyer
                            </p>
                            
                            <div style="display: flex; gap: 10px; justify-content: flex-end;">
                                <button class="btn btn-secondary" onclick="document.getElementById('notifyModal').remove()">
                                    Annuler
                                </button>
                                <button class="btn btn-success" onclick="hdnApp.sendNotifications(${enigmaNumber}, '${enigmaTitle.replace(/'/g, "\\'")}', ${JSON.stringify(playersUpToDate.map(p => p.email)).replace(/"/g, '&quot;')}, ${JSON.stringify(playersBehind.map(p => p.email)).replace(/"/g, '&quot;')})">
                                    üìß Envoyer ${playersUpToDate.length + playersBehind.length} emails
                                </button>
                            </div>
                        </div>
                    `;
                    document.body.appendChild(modal);

                } catch (error) {
                    console.error('Error:', error);
                    showToast('‚ùå Erreur lors de l\'analyse', 'error');
                }
            },

            async sendNotifications(enigmaNumber, enigmaTitle, playersUpToDate, playersBehind) {
                // Fermer la modal
                document.getElementById('notifyModal')?.remove();

                showToast('üìß Envoi des emails en cours...', 'info');

                try {
                    const response = await fetch(this.WORKER_URL, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            enigmaNumber,
                            enigmaTitle,
                            playersUpToDate,
                            playersBehind
                        })
                    });

                    const result = await response.json();

                    if (result.success) {
                        showToast(`‚úÖ ${result.sent} emails envoy√©s !`, 'success');
                        if (result.errors > 0) {
                            console.warn('Email errors:', result.details);
                            showToast(`‚ö†Ô∏è ${result.errors} erreur(s) d'envoi`, 'warning');
                        }
                    } else {
                        throw new Error(result.error || 'Erreur inconnue');
                    }

                } catch (error) {
                    console.error('Error:', error);
                    showToast('‚ùå Erreur lors de l\'envoi: ' + error.message, 'error');
                }
            },

            async exportData() {
                // Admin check
                if (!this.currentUser?.is_admin) {
                    showToast('‚ùå Acc√®s refus√© - Admin uniquement', 'error');
                    return;
                }

                try {
                    // Export without passwords
                    const { data: players } = await supabase
                        .from('players')
                        .select('id, pseudo, type, points, team_id, is_admin, is_test, created_at');
                    const { data: teams } = await supabase
                        .from('teams')
                        .select('id, name, code, points, leader, created_at');
                    const { data: enigmas } = await supabase
                        .from('enigmas')
                        .select('id, number, title, description, answer, location, qr_secret, validation_type, hint1, hint2, hint3, published, scheduled_at');
                    const { data: progress } = await supabase
                        .from('enigma_progress')
                        .select('*');
                    const { data: submissions } = await supabase
                        .from('submissions')
                        .select('*');

                    const exportData = {
                        exported_at: new Date().toISOString(),
                        players,
                        teams,
                        enigmas,
                        progress,
                        submissions
                    };

                    const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `hdn-export-${new Date().toISOString().split('T')[0]}.json`;
                    a.click();

                    showToast('‚úÖ Donn√©es export√©es !', 'success');

                } catch (error) {
                    console.error('Error:', error);
                    showToast('‚ùå Erreur lors de l\'export', 'error');
                }
            }
        };

        // Initialize app when page loads
        document.addEventListener('DOMContentLoaded', () => {
            hdnApp.init();

            // √âcouter les messages du jeu (√âpreuve Finale)
            let gameCompleteInProgress = false;

            window.addEventListener('message', async (event) => {
                if (event.data && event.data.type === 'GAME_COMPLETE') {
                    const { token, score, totalTimeMs, deaths } = event.data;
                    console.log('Game complete received:', { token, score, totalTimeMs, deaths });
                    gameCompleteInProgress = true;
                    await hdnApp.handleGameComplete(token, score, totalTimeMs, deaths || 0);
                    gameCompleteInProgress = false;
                }

                // Mode fun - enregistrer le score dans le leaderboard sans points officiels
                if (event.data && event.data.type === 'GAME_FUN_COMPLETE') {
                    const { playerId, enigmaId, totalTimeMs, deaths } = event.data;
                    console.log('Fun game complete received:', { playerId, enigmaId, totalTimeMs, deaths });

                    try {
                        const { data: improved, error } = await supabase.rpc('submit_game_score', {
                            p_player_id: parseInt(playerId),
                            p_enigma_id: parseInt(enigmaId),
                            p_time_ms: totalTimeMs,
                            p_deaths: deaths || 0
                        });

                        if (error) {
                            console.error('Error submitting fun score:', error);
                        } else if (improved) {
                            showToast('üéâ Nouveau record personnel !', 'success');
                        } else {
                            showToast('‚úÖ Partie termin√©e !', 'info');
                        }

                        // Rafra√Æchir le classement si on est sur l'onglet mini-jeu
                        if (document.getElementById('minigame-section').classList.contains('active')) {
                            await hdnApp.loadGameLeaderboard();
                        }
                    } catch (e) {
                        console.error('Error in fun mode:', e);
                    }
                }

                // V√©rifier si l'√©quipe a d√©j√† compl√©t√© le jeu
                if (event.data && event.data.type === 'GAME_CHECK_TEAM_STATUS') {
                    const { token } = event.data;
                    const alreadyCompleted = await hdnApp.checkTeamGameStatus(token);

                    // R√©pondre au jeu
                    const gameIframe = document.getElementById('gameIframe');
                    if (gameIframe && gameIframe.contentWindow) {
                        gameIframe.contentWindow.postMessage({
                            type: 'GAME_TEAM_STATUS',
                            alreadyCompleted: alreadyCompleted
                        }, '*');
                    }
                }

                // Fermer le jeu quand demand√©
                if (event.data && event.data.type === 'GAME_CLOSE_REQUEST') {
                    // Attendre que handleGameComplete soit termin√© si en cours
                    if (gameCompleteInProgress) {
                        console.log('Waiting for game complete to finish...');
                        // Attendre max 5 secondes
                        let waited = 0;
                        while (gameCompleteInProgress && waited < 5000) {
                            await new Promise(r => setTimeout(r, 100));
                            waited += 100;
                        }
                    }
                    hdnApp.closeGame();
                }
            });
        });
    </script>
</body>

</html>